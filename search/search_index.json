{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Flox","text":"<p>Flox is a modular C++ framework for building ultra-low-latency execution systems. It provides a strict separation between abstract interfaces and high-performance implementations, designed for:</p> <ul> <li>Real-time and historical trading infrastructure</li> <li>Event-driven architecture with tick-level granularity</li> <li>Unified simulation and live execution environments</li> <li>Deterministic latency and memory control</li> </ul>"},{"location":"#highlights","title":"Highlights","text":"<ul> <li>Pluggable exchange connectors via <code>ExchangeConnector</code> and <code>ConnectorFactory</code></li> <li>Lock-free <code>EventBus</code> with support for both sync and async fan-out</li> <li>Fast tick-aligned in-memory order books (<code>NLevelOrderBook</code>)</li> <li>Strategy layer with explicit lifecycle and bus integration</li> <li>Unified <code>IMarketDataSubscriber</code> interface for book, trade, and candle events</li> <li>Modular design: each component is testable, swappable, and lifecycle-aware</li> <li>Explicit memory and object reuse via pooled <code>Handle&lt;T&gt;</code> and <code>Pool&lt;T&gt;</code></li> </ul>"},{"location":"architecture/","title":"Architecture","text":"<p>Flox is a modular framework for building low-latency execution systems. Its design emphasizes separation of concerns, predictable performance, and composability.</p>"},{"location":"architecture/#layers-of-the-architecture","title":"Layers of the Architecture","text":""},{"location":"architecture/#1-abstract-layer","title":"1. Abstract Layer","text":"<p>Defines pure interfaces with no internal state. These are the contracts your system is built upon:</p> <ul> <li><code>IStrategy</code>: strategy logic</li> <li><code>IOrderExecutor</code>: order submission</li> <li><code>IOrderExecutionListener</code>: execution events</li> <li><code>IRiskManager</code>, <code>IOrderValidator</code>, <code>IPositionManager</code>: trade controls and state</li> <li><code>IOrderBook</code>, <code>ExchangeConnector</code>: market structure</li> <li><code>ISubsystem</code>: unified lifecycle interface</li> <li><code>IMarketDataSubscriber</code>: receives events via data bus</li> </ul>"},{"location":"architecture/#why-it-matters","title":"Why it matters","text":"<ul> <li>Enables simulation, replay, and mocking</li> <li>Decouples logic from implementation</li> <li>Ensures correctness can be validated independently of performance</li> </ul>"},{"location":"architecture/#2-implementation-layer","title":"2. Implementation Layer","text":"<ul> <li><code>Engine</code>: orchestrates startup and shutdown</li> <li><code>NLevelOrderBook</code>: in-memory order book with tick-aligned price levels</li> <li><code>CandleAggregator</code>: aggregates trades into fixed-interval OHLCV candles</li> <li><code>SymbolRegistry</code>: maps <code>(exchange:symbol)</code> pairs to compact <code>SymbolId</code></li> <li><code>EventBus</code>: event fan-out with push/pull delivery modes and sync/async policy</li> <li><code>BookUpdateEvent</code>, <code>TradeEvent</code>: pooled, reusable market data structures</li> </ul>"},{"location":"architecture/#features","title":"Features","text":"<ul> <li>Speed: tight memory layout, preallocated event structures</li> <li>Control: no heap allocation in event flow, deterministic dispatch</li> <li>Modularity: all components are independently replaceable and testable</li> </ul>"},{"location":"architecture/#strategy-execution-push-and-pull-modes","title":"Strategy Execution: PUSH and PULL Modes","text":"<p>Strategies implement <code>IMarketDataSubscriber</code> and can operate in two modes:</p>"},{"location":"architecture/#push-mode-default","title":"PUSH Mode (default)","text":"<p>The bus actively delivers events to the strategy:</p> <pre><code>class MyPushStrategy : public IStrategy {\npublic:\n  void onBookUpdate(const BookUpdateEvent&amp; ev) override { /* handle event */ }\n};\n</code></pre> <pre><code>marketDataBus-&gt;subscribe(strategy);\n</code></pre>"},{"location":"architecture/#pull-mode","title":"PULL Mode","text":"<p>The strategy explicitly drains its queue:</p> <pre><code>class MyPullStrategy : public IMarketDataSubscriber {\npublic:\n  SubscriberMode mode() const override { return SubscriberMode::PULL; }\n\n  void readLoop(SPSCQueue&lt;EventHandle&lt;BookUpdateEvent&gt;&gt;&amp; queue) {\n    EventHandle&lt;BookUpdateEvent&gt; ev;\n    while (queue.pop(ev)) {\n      EventDispatcher&lt;EventHandle&lt;BookUpdateEvent&gt;&gt;::dispatch(ev, *this);\n    }\n  }\n};\n</code></pre>"},{"location":"architecture/#market-data-fan-out-marketdatabus","title":"Market Data Fan-Out: MarketDataBus","text":"<p>The <code>MarketDataBus</code> delivers <code>EventHandle&lt;T&gt;</code> to each subscriber using dedicated <code>SPSCQueue</code>s.</p>"},{"location":"architecture/#publishing","title":"Publishing:","text":"<pre><code>bus-&gt;publish(std::move(bookUpdate));\n</code></pre>"},{"location":"architecture/#subscribing","title":"Subscribing:","text":"<pre><code>bus-&gt;subscribe(myStrategy);\n</code></pre>"},{"location":"architecture/#behavior","title":"Behavior:","text":"<ul> <li>Each subscriber has an isolated queue</li> <li>Events are delivered via <code>EventDispatcher</code></li> <li>In <code>SyncPolicy</code>, all subscribers are synchronized via <code>TickBarrier</code> and <code>TickGuard</code></li> </ul>"},{"location":"architecture/#lifecycle-and-subsystems","title":"Lifecycle and Subsystems","text":"<p>All major components implement <code>ISubsystem</code>, exposing <code>start()</code> and <code>stop()</code> methods.</p> <p>Benefits:</p> <ul> <li>Deterministic lifecycle control</li> <li>Support for warm-up, teardown, benchmarking</li> <li>Simplified simulation and test orchestration</li> </ul>"},{"location":"architecture/#memory-and-performance","title":"Memory and Performance","text":"<p>Flox is designed for allocation-free execution on the hot path:</p> <ul> <li><code>BookUpdateEvent</code>, <code>TradeEvent</code> come from <code>Pool&lt;T&gt;</code></li> <li><code>Handle&lt;T&gt;</code> ensures safe ref-counted reuse</li> <li><code>SPSCQueue</code> provides lock-free delivery</li> <li><code>std::pmr::vector</code> used in <code>BookUpdate</code> avoids heap churn</li> </ul>"},{"location":"architecture/#symbol-centric-design","title":"Symbol-Centric Design","text":"<p>All routing and lookup is based on <code>SymbolId</code> (<code>uint32_t</code>):</p> <ul> <li>Fast lookup, avoids string comparison</li> <li>Enables per-symbol state machines, queues, books</li> <li>Supports dense fan-out architectures</li> </ul>"},{"location":"architecture/#intended-use","title":"Intended Use","text":"<p>Flox is not a full trading engine \u2014 it\u2019s a toolkit for building:</p> <ul> <li>Real-time trading systems</li> <li>Simulators and replay backtesters</li> <li>Signal fan-out and market data routers</li> <li>Custom HFT infrastructure</li> </ul> <p>Designed for teams that require:</p> <ul> <li>Predictable low-latency performance</li> <li>Explicit memory and thread control</li> <li>Modular, testable architecture</li> </ul>"},{"location":"architecture/#example-integration","title":"Example Integration","text":"<pre><code>auto strategy = std::make_shared&lt;MyStrategy&gt;();\nmarketDataBus-&gt;subscribe(strategy);\n\nmarketDataBus-&gt;publish(std::move(bookUpdate));\n</code></pre> <p>In pull-mode:</p> <pre><code>auto* queue = marketDataBus-&gt;getQueue(strategy-&gt;id());\nEventHandle&lt;BookUpdateEvent&gt; ev;\nwhile (queue-&gt;pop(ev)) {\n  EventDispatcher&lt;EventHandle&lt;BookUpdateEvent&gt;&gt;::dispatch(ev, *strategy);\n}\n</code></pre>"},{"location":"architecture/#summary","title":"Summary","text":"<p>Flox is:</p> <ul> <li>Modular \u2014 use only what you need</li> <li>Deterministic \u2014 fully controlled event timing</li> <li>Safe \u2014 no hidden allocations, pooled memory</li> <li>Flexible \u2014 works in backtests, simulation, and live systems</li> </ul> <p>You define the logic \u2014 Flox moves the data.</p>"},{"location":"components/common/","title":"Common Types","text":"<p>This header defines core types and enums used throughout the Flox engine, including identifiers, numeric types (price, quantity), and domain-specific enums.</p>"},{"location":"components/common/#enums","title":"Enums","text":""},{"location":"components/common/#ordertype","title":"<code>OrderType</code>","text":"<p>Represents the execution style of an order.</p> <pre><code>enum class OrderType {\n  LIMIT,\n  MARKET\n};\n</code></pre>"},{"location":"components/common/#side","title":"<code>Side</code>","text":"<p>Represents the direction of an order.</p> <pre><code>enum class Side {\n  BUY,\n  SELL\n};\n</code></pre>"},{"location":"components/common/#identifiers","title":"Identifiers","text":"Type Description <code>SymbolId</code> Unique identifier for a symbol. <code>OrderId</code> Unique identifier for an order."},{"location":"components/common/#fixed-point-types","title":"Fixed-Point Types","text":"<p>Built on top of the <code>Decimal</code> template for safe, precise arithmetic.</p> Type Scale Description <code>Price</code> 1e-6 Decimal representation of price. <code>Quantity</code> 1e-6 Decimal quantity (e.g. number of contracts). <code>Volume</code> 1e-6 Price \u00d7 Quantity, used in candle bars etc. <p>All three types use <code>Decimal&lt;Tag, 1'000'000, 1&gt;</code> internally, ensuring:</p> <ul> <li>High precision (6 decimal places)</li> <li>Strong typing (tags prevent mixing price and size)</li> <li>Tick-aligned operations and rounding support</li> </ul>"},{"location":"components/common/#notes","title":"Notes","text":"<ul> <li>These types are used pervasively across all order-related and market data structures.</li> <li>Prevents accidental unit mismatches (e.g., adding price and quantity).</li> <li>Tick size granularity is currently fixed to <code>1</code>.</li> </ul>"},{"location":"components/aggregator/candle_aggregator/","title":"CandleAggregator","text":"<p><code>CandleAggregator</code> transforms incoming <code>TradeEvent</code>s into time-aligned OHLCV candles and broadcasts them via <code>CandleBus</code>.</p> <pre><code>class CandleAggregator : public ISubsystem, public IMarketDataSubscriber {\npublic:\n  CandleAggregator(std::chrono::seconds interval, CandleBus* bus);\n  void start() override;\n  void stop() override;\n\n  SubscriberId id() const override;\n  SubscriberMode mode() const override;\n\n  void onTrade(const TradeEvent&amp; trade) override;\n\nprivate:\n  struct PartialCandle {\n    Candle candle;\n    bool initialized = false;\n  };\n\n  std::chrono::seconds _interval;\n  CandleBus* _bus;\n  std::vector&lt;std::optional&lt;PartialCandle&gt;&gt; _candles;\n\n  std::chrono::steady_clock::time_point alignToInterval(std::chrono::steady_clock::time_point tp);\n};\n</code></pre>"},{"location":"components/aggregator/candle_aggregator/#purpose","title":"Purpose","text":"<ul> <li>Buffer and roll trades into interval-based candles, suitable for downstream analytics or strategy inputs.</li> </ul>"},{"location":"components/aggregator/candle_aggregator/#responsibilities","title":"Responsibilities","text":"Aspect Details Interval Candle size defined by <code>_interval</code>, validated at construction. Event input Consumes only <code>TradeEvent</code>; no handling for books or candles. Event output Emits <code>CandleEvent</code> to all subscribers via <code>CandleBus</code>. Lifecycle Hooks into engine via <code>ISubsystem::start()</code> and <code>stop()</code>. Subscriber ID Uses object pointer as a unique <code>SubscriberId</code>. Mode Operates in <code>PUSH</code> mode for direct event delivery."},{"location":"components/aggregator/candle_aggregator/#internal-behavior","title":"Internal Behavior","text":"<ol> <li> <p>Time Slot Alignment    Trade timestamps are aligned using <code>alignToInterval()</code> to find the start of the containing interval.</p> </li> <li> <p>Per-Symbol Buffering <code>_candles</code> is a <code>std::vector&lt;std::optional&lt;PartialCandle&gt;&gt;</code>, indexed by <code>SymbolId</code>, pre-sized for all known symbols.</p> </li> <li> <p>Candle Rollover    If a trade belongs to a new interval, the previous candle is finalized and sent; a new <code>PartialCandle</code> is started.</p> </li> <li> <p>No Hot Allocations    Once the vector is initialized, the hot path is allocation-free; avoids <code>unordered_map</code> lookup cost.</p> </li> </ol>"},{"location":"components/aggregator/candle_aggregator/#notes","title":"Notes","text":"<ul> <li>Designed for maximum cache-friendliness and fan-out throughput.</li> <li>Ignores out-of-order or backdated trades \u2014 assumes input stream is clean and ordered.</li> <li>Fully decoupled via <code>CandleBus</code>; downstream consumers remain unaware of source logic.</li> </ul>"},{"location":"components/aggregator/bus/candle_bus/","title":"CandleBus","text":"<p><code>CandleBus</code> is a publish-subscribe channel for <code>CandleEvent</code> messages, used to deliver aggregated candles from <code>CandleAggregator</code> to downstream consumers (e.g., strategies, loggers).</p> <pre><code>#ifdef USE_SYNC_CANDLE_BUS\nusing CandleBus = EventBus&lt;CandleEvent, SyncPolicy&lt;CandleEvent&gt;&gt;;\n#else\nusing CandleBus = EventBus&lt;CandleEvent, AsyncPolicy&lt;CandleEvent&gt;&gt;;\n#endif\n</code></pre>"},{"location":"components/aggregator/bus/candle_bus/#purpose","title":"Purpose","text":"<ul> <li>Fan-out distribution of <code>CandleEvent</code> to all registered subscribers.</li> </ul>"},{"location":"components/aggregator/bus/candle_bus/#responsibilities","title":"Responsibilities","text":"Aspect Details Policy Chooses between <code>SyncPolicy</code> and <code>AsyncPolicy</code> via compile-time flag. Binding Type alias for <code>EventBus&lt;CandleEvent, Policy&gt;</code>. Usage Integrated into <code>CandleAggregator</code>; consumed by strategies and metrics."},{"location":"components/aggregator/bus/candle_bus/#notes","title":"Notes","text":"<ul> <li><code>SyncPolicy</code> ensures deterministic tick-to-tick sequencing for backtesting.</li> <li><code>AsyncPolicy</code> enables low-latency lock-free fan-out in live trading.</li> <li>Controlled via the <code>USE_SYNC_CANDLE_BUS</code> macro, toggled at compile time.</li> </ul>"},{"location":"components/aggregator/events/candle_event/","title":"CandleEvent","text":"<p><code>CandleEvent</code> represents a finalized OHLCV candle for a specific symbol and time interval, emitted by <code>CandleAggregator</code> and delivered via <code>CandleBus</code>.</p> <pre><code>struct CandleEvent {\n  using Listener = IMarketDataSubscriber;\n\n  SymbolId symbol{};\n  Candle   candle{};\n  uint64_t tickSequence = 0;\n};\n</code></pre>"},{"location":"components/aggregator/events/candle_event/#purpose","title":"Purpose","text":"<ul> <li>Encapsulate a single time-aggregated candle (<code>Candle</code>) with metadata for delivery.</li> </ul>"},{"location":"components/aggregator/events/candle_event/#responsibilities","title":"Responsibilities","text":"Aspect Details Symbol <code>symbol</code> identifies the market instrument. Payload <code>candle</code> contains OHLCV data for the interval. Sequencing <code>tickSequence</code> ensures deterministic delivery in sync-mode processing. Subscription Defines <code>IMarketDataSubscriber</code> as listener type for <code>CandleBus</code>."},{"location":"components/aggregator/events/candle_event/#notes","title":"Notes","text":"<ul> <li><code>tickSequence</code> enables strict event ordering under <code>SyncPolicy</code>.</li> <li>Used in both live and simulated environments.</li> <li><code>CandleEvent</code> is a plain data object; no logic or ownership semantics.</li> </ul>"},{"location":"components/book/abstract_order_book/","title":"IOrderBook","text":"<p><code>IOrderBook</code> defines the abstract interface for order book implementations that consume <code>BookUpdateEvent</code>s and provide access to market depth and price levels.</p> <pre><code>class IOrderBook {\npublic:\n  virtual ~IOrderBook() = default;\n\n  virtual void applyBookUpdate(const BookUpdateEvent&amp; update) = 0;\n  virtual std::optional&lt;Price&gt; bestBid() const = 0;\n  virtual std::optional&lt;Price&gt; bestAsk() const = 0;\n\n  virtual Quantity bidAtPrice(Price price) const = 0;\n  virtual Quantity askAtPrice(Price price) const = 0;\n};\n</code></pre>"},{"location":"components/book/abstract_order_book/#purpose","title":"Purpose","text":"<ul> <li>Define a common contract for order book consumers, simulators, and strategy components.</li> </ul>"},{"location":"components/book/abstract_order_book/#responsibilities","title":"Responsibilities","text":"Aspect Details Update <code>applyBookUpdate()</code> ingests raw changes from <code>BookUpdateEvent</code>. Top of book <code>bestBid()</code> / <code>bestAsk()</code> expose inside market prices. Depth query <code>bidAtPrice()</code> / <code>askAtPrice()</code> return size at arbitrary levels."},{"location":"components/book/abstract_order_book/#notes","title":"Notes","text":"<ul> <li>Stateless interface \u2014 actual book implementation (e.g. <code>NLevelOrderBook</code>) manages memory and performance.</li> <li>Compatible with pooled update dispatch via <code>BookUpdateBus</code>.</li> <li>Returns <code>std::optional</code> for top-of-book queries to reflect potential emptiness.</li> </ul>"},{"location":"components/book/book_update/","title":"BookUpdate","text":"<p><code>BookUpdate</code> is a memory-efficient container for transmitting order book snapshots or deltas, optimized for high-frequency processing via polymorphic memory resources.</p> <pre><code>struct BookUpdate {\n  SymbolId symbol{};\n  BookUpdateType type{};\n  std::pmr::vector&lt;BookLevel&gt; bids;\n  std::pmr::vector&lt;BookLevel&gt; asks;\n  std::chrono::steady_clock::time_point timestamp{};\n\n  BookUpdate(std::pmr::memory_resource* res);\n};\n</code></pre>"},{"location":"components/book/book_update/#purpose","title":"Purpose","text":"<ul> <li>Represent a normalized order book update \u2014 either full snapshot or incremental delta \u2014 using preallocated memory.</li> </ul>"},{"location":"components/book/book_update/#responsibilities","title":"Responsibilities","text":"Aspect Details Symbol <code>symbol</code> identifies the instrument the update refers to. Update Type <code>SNAPSHOT</code> or <code>DELTA</code>, used to drive order book reconstruction logic. Levels <code>bids</code> and <code>asks</code> contain depth updates as <code>BookLevel</code> entries. Timestamp Captures the original receive time for sequencing and latency analysis. Allocation All storage comes from a user-provided <code>std::pmr::memory_resource</code>."},{"location":"components/book/book_update/#notes","title":"Notes","text":"<ul> <li>Designed for zero-allocation processing when paired with object pools and pre-sized buffers.</li> <li>Used in both simulated and real-time environments.</li> <li>Consumers must respect the <code>BookUpdateType</code> semantics \u2014 <code>SNAPSHOT</code> implies a full overwrite.</li> </ul>"},{"location":"components/book/candle/","title":"Candle","text":"<p><code>Candle</code> represents a single OHLCV time-bar aggregated from trades within a fixed interval.</p> <pre><code>struct Candle {\n  Price open;\n  Price high;\n  Price low;\n  Price close;\n  Volume volume;\n  std::chrono::steady_clock::time_point startTime;\n  std::chrono::steady_clock::time_point endTime;\n\n  Candle() = default;\n  Candle(std::chrono::steady_clock::time_point ts, Price price, Volume qty);\n};\n</code></pre>"},{"location":"components/book/candle/#purpose","title":"Purpose","text":"<ul> <li>Store the full market state (OHLCV) over a defined time window for downstream analytics or strategy input.</li> </ul>"},{"location":"components/book/candle/#responsibilities","title":"Responsibilities","text":"Field Description open Price of the first trade in the interval. high/low Highest and lowest traded price during the interval. close Price of the last trade in the interval. volume Total traded volume across all ticks in the window. startTime Timestamp of the first trade in the interval. endTime Timestamp of the last trade in the interval (may evolve)."},{"location":"components/book/candle/#notes","title":"Notes","text":"<ul> <li>Constructed with initial price/volume; high/low/close evolve with subsequent trades.</li> <li>Timestamps are <code>steady_clock</code>-based to support simulation and deterministic replay.</li> <li>Used exclusively by <code>CandleAggregator</code> and delivered via <code>CandleEvent</code>.</li> </ul>"},{"location":"components/book/nlevel_order_book/","title":"NLevelOrderBook","text":"<p><code>NLevelOrderBook</code> is a high-performance, fixed-depth limit order book optimized for HFT and simulation. It uses tick-based indexing for fast access and zero allocations in the hot path.</p> <pre><code>template &lt;size_t MaxLevels = 8192&gt;\nclass NLevelOrderBook : public IOrderBook {\n  // ...\n};\n</code></pre>"},{"location":"components/book/nlevel_order_book/#purpose","title":"Purpose","text":"<ul> <li>Maintain and query an efficient in-memory representation of top-of-book and full depth using indexed price levels.</li> </ul>"},{"location":"components/book/nlevel_order_book/#responsibilities","title":"Responsibilities","text":"Aspect Details Input Consumes <code>BookUpdateEvent</code> messages, supports both <code>SNAPSHOT</code> and <code>DELTA</code>. Resolution Tick-based price quantization via <code>_tickSize</code>. Depth Query Provides <code>bestBid</code>, <code>bestAsk</code>, and <code>Quantity</code> at arbitrary price levels. Storage Preallocated arrays for bids and asks indexed by tick-level offset."},{"location":"components/book/nlevel_order_book/#internal-behavior","title":"Internal Behavior","text":"<ol> <li> <p>Price Indexing    Prices are mapped to array indices using <code>price / tickSize</code>, enabling constant-time access.</p> </li> <li> <p>Snapshot Handling    A <code>SNAPSHOT</code> clears all state and resets index bounds before applying levels.</p> </li> <li> <p>Bounds Tracking    Maintains <code>_minBidIndex</code>, <code>_maxBidIndex</code>, <code>_minAskIndex</code>, <code>_maxAskIndex</code> for efficient best-level scans.</p> </li> <li> <p>Best Bid/Ask Scan    Performs linear scans within index bounds to locate top of book \u2014 fast due to tight range.</p> </li> <li> <p>No Dynamic Allocation    Uses <code>std::array</code> of fixed size; fully cache-friendly and allocation-free after construction.</p> </li> </ol>"},{"location":"components/book/nlevel_order_book/#notes","title":"Notes","text":"<ul> <li>Extremely fast and deterministic \u2014 suitable for backtests and production.</li> <li>Requires external enforcement of tick-aligned prices.</li> <li>Offers predictable latency across workloads, assuming sparse updates.</li> </ul>"},{"location":"components/book/trade/","title":"Trade","text":"<p><code>Trade</code> represents a single executed transaction between a buyer and seller on a specific symbol, including price, quantity, and taker side.</p> <pre><code>struct Trade {\n  SymbolId symbol{};\n  Price price{};\n  Quantity quantity{};\n  bool isBuy{false};\n  std::chrono::steady_clock::time_point timestamp{};\n};\n</code></pre>"},{"location":"components/book/trade/#purpose","title":"Purpose","text":"<ul> <li>Convey executed market activity in a normalized format for downstream processing.</li> </ul>"},{"location":"components/book/trade/#responsibilities","title":"Responsibilities","text":"Field Description symbol Identifies the traded instrument. price Execution price of the trade. quantity Size of the trade (in base units). isBuy True if taker was buyer; false if taker was seller. timestamp Wall-clock or event time of execution, using <code>steady_clock</code>."},{"location":"components/book/trade/#notes","title":"Notes","text":"<ul> <li>Used in <code>TradeEvent</code>, which is dispatched through <code>TradeBus</code>.</li> <li>Serves as input for aggregation, PnL tracking, and order flow analysis.</li> <li><code>isBuy</code> expresses taker aggressiveness \u2014 not resting order direction.</li> </ul>"},{"location":"components/book/bus/book_update_bus/","title":"BookUpdateBus","text":"<p><code>BookUpdateBus</code> is a fan-out event channel for <code>BookUpdateEvent</code> messages, wrapped in pooled <code>Handle</code>s for zero-allocation delivery across components such as order books, strategies, and analytics.</p> <pre><code>#ifdef USE_SYNC_MARKET_BUS\nusing BookUpdateBus = EventBus&lt;pool::Handle&lt;BookUpdateEvent&gt;, SyncPolicy&lt;...&gt;&gt;;\n#else\nusing BookUpdateBus = EventBus&lt;pool::Handle&lt;BookUpdateEvent&gt;, AsyncPolicy&lt;...&gt;&gt;;\n#endif\n</code></pre>"},{"location":"components/book/bus/book_update_bus/#purpose","title":"Purpose","text":"<ul> <li>Efficiently distribute <code>BookUpdateEvent</code>s to multiple subscribers with zero allocations in the hot path.</li> </ul>"},{"location":"components/book/bus/book_update_bus/#responsibilities","title":"Responsibilities","text":"Aspect Details Payload Uses <code>pool::Handle&lt;BookUpdateEvent&gt;</code> for memory reuse and ref-counting. Mode <code>SyncPolicy</code> or <code>AsyncPolicy</code>, toggled by <code>USE_SYNC_MARKET_BUS</code>. Target Consumed by order book processors, strategies, and market monitors."},{"location":"components/book/bus/book_update_bus/#notes","title":"Notes","text":"<ul> <li><code>SyncPolicy</code> enforces barrier-based delivery (e.g., for simulation or determinism).</li> <li><code>AsyncPolicy</code> supports lock-free fan-out under production latency constraints.</li> <li>Pooling ensures <code>BookUpdateEvent</code>s are reused without dynamic heap allocations.</li> <li>Designed for high-frequency message flow in HFT environments.</li> </ul>"},{"location":"components/book/bus/trade_bus/","title":"TradeBus","text":"<p><code>TradeBus</code> is a high-throughput delivery channel for <code>TradeEvent</code> messages, used to broadcast trade prints across system components such as aggregators, strategies, and analytics modules.</p> <pre><code>#ifdef USE_SYNC_MARKET_BUS\nusing TradeBus = EventBus&lt;TradeEvent, SyncPolicy&lt;TradeEvent&gt;&gt;;\n#else\nusing TradeBus = EventBus&lt;TradeEvent, AsyncPolicy&lt;TradeEvent&gt;&gt;;\n#endif\n</code></pre>"},{"location":"components/book/bus/trade_bus/#purpose","title":"Purpose","text":"<ul> <li>Propagate real-time <code>TradeEvent</code>s to all registered consumers in the system.</li> </ul>"},{"location":"components/book/bus/trade_bus/#responsibilities","title":"Responsibilities","text":"Aspect Details Payload Direct delivery of <code>TradeEvent</code> instances (no wrapping or pooling). Mode Chooses between <code>SyncPolicy</code> and <code>AsyncPolicy</code> via compile-time macro. Usage Used by connectors, aggregators (e.g., <code>CandleAggregator</code>), and strategies."},{"location":"components/book/bus/trade_bus/#notes","title":"Notes","text":"<ul> <li><code>SyncPolicy</code> guarantees deterministic tick-to-tick replay for simulation/backtesting.</li> <li><code>AsyncPolicy</code> offers lock-free fan-out for live environments with minimal latency.</li> <li>Stateless; the bus itself performs no buffering or transformation.</li> </ul>"},{"location":"components/book/events/book_update_event/","title":"BookUpdateEvent","text":"<p><code>BookUpdateEvent</code> represents a snapshot or delta update to the order book, encapsulated in a pooled, memory-resource-aware structure for zero-allocation fan-out.</p> <pre><code>struct BookUpdateEvent : public pool::PoolableBase&lt;BookUpdateEvent&gt; {\n  using Listener = IMarketDataSubscriber;\n\n  BookUpdate update;\n  uint64_t tickSequence = 0;\n\n  BookUpdateEvent(std::pmr::memory_resource* res);\n  void clear();\n};\n</code></pre>"},{"location":"components/book/events/book_update_event/#purpose","title":"Purpose","text":"<ul> <li>Deliver normalized order book changes with minimal latency and no heap allocations.</li> </ul>"},{"location":"components/book/events/book_update_event/#responsibilities","title":"Responsibilities","text":"Aspect Details Memory Constructed with <code>std::pmr::memory_resource</code> for scoped allocation. Pooling Inherits from <code>PoolableBase</code> for reuse via <code>pool::Handle&lt;T&gt;</code>. Payload Holds a <code>BookUpdate</code> with bid/ask vectors allocated from the PMR. Sequencing <code>tickSequence</code> ensures ordered processing across consumers. Subscription Declares <code>IMarketDataSubscriber</code> as the receiver interface."},{"location":"components/book/events/book_update_event/#notes","title":"Notes","text":"<ul> <li><code>clear()</code> resets bid/ask containers in-place without releasing memory.</li> <li>Intended for high-frequency delivery over <code>BookUpdateBus</code>.</li> <li>Construction asserts non-null memory resource to enforce deterministic allocation control.</li> <li>Immutable after dispatch; reused through pooled lifecycle.</li> </ul>"},{"location":"components/book/events/trade_event/","title":"TradeEvent","text":"<p><code>TradeEvent</code> represents a single trade tick \u2014 a filled transaction between counterparties \u2014 and is broadcast across the system for aggregation, analytics, and strategy input.</p> <pre><code>struct TradeEvent {\n  using Listener = IMarketDataSubscriber;\n\n  Trade trade{};\n  uint64_t tickSequence = 0;\n};\n</code></pre>"},{"location":"components/book/events/trade_event/#purpose","title":"Purpose","text":"<ul> <li>Encapsulate trade prints received from exchanges for delivery via <code>TradeBus</code>.</li> </ul>"},{"location":"components/book/events/trade_event/#responsibilities","title":"Responsibilities","text":"Aspect Details Payload <code>trade</code> holds symbol, price, quantity, timestamp, and taker direction. Sequencing <code>tickSequence</code> guarantees strict event order for replay and backtests. Subscription Targets <code>IMarketDataSubscriber</code> interface for generic event delivery."},{"location":"components/book/events/trade_event/#notes","title":"Notes","text":"<ul> <li>Used by <code>CandleAggregator</code>, PnL trackers, and all signal generation components.</li> <li>Designed for ultra-low-latency delivery; no heap allocation involved.</li> <li>Stateless container \u2014 no logic beyond encapsulation.</li> </ul>"},{"location":"components/connector/connector_factory/","title":"ConnectorFactory","text":"<p><code>ConnectorFactory</code> is a global registry and dynamic constructor for <code>ExchangeConnector</code> instances, used to instantiate exchange adapters based on type and symbol at runtime.</p> <pre><code>class ConnectorFactory {\npublic:\n  using CreatorFunc = std::move_only_function&lt;std::shared_ptr&lt;ExchangeConnector&gt;(const std::string&amp;)&gt;;\n\n  static ConnectorFactory&amp; instance();\n  void registerConnector(const std::string&amp; type, CreatorFunc creator);\n  std::shared_ptr&lt;ExchangeConnector&gt; createConnector(const std::string&amp; type, const std::string&amp; symbol);\n\nprivate:\n  std::unordered_map&lt;std::string, CreatorFunc&gt; _creators;\n};\n</code></pre>"},{"location":"components/connector/connector_factory/#purpose","title":"Purpose","text":"<ul> <li>Enable pluggable, type-based instantiation of exchange connectors without static bindings.</li> </ul>"},{"location":"components/connector/connector_factory/#responsibilities","title":"Responsibilities","text":"Aspect Details Registration Maps string identifiers (e.g. <code>\"bybit\"</code>, <code>\"mock\"</code>) to creator functions. Construction Calls registered factory to produce a connector for a given <code>symbol</code>. Lifetime Singleton pattern via <code>instance()</code>; all connectors share same registry."},{"location":"components/connector/connector_factory/#notes","title":"Notes","text":"<ul> <li>Uses <code>std::move_only_function</code> to avoid overhead of <code>std::function</code> and enable capture of ownership semantics.</li> <li>Supports dynamic module systems or runtime configuration of connector types.</li> <li>Not thread-safe by default \u2014 external synchronization may be required during registration.</li> </ul>"},{"location":"components/connector/connector_manager/","title":"ConnectorManager","text":"<p><code>ConnectorManager</code> coordinates lifecycle and callback wiring for multiple <code>ExchangeConnector</code> instances, managing startup and routing of market data events.</p> <pre><code>class ConnectorManager {\npublic:\n  void registerConnector(std::shared_ptr&lt;ExchangeConnector&gt; connector);\n  void startAll(ExchangeConnector::BookUpdateCallback onBookUpdate,\n                ExchangeConnector::TradeCallback onTrade);\n\nprivate:\n  std::map&lt;std::string, std::shared_ptr&lt;ExchangeConnector&gt;&gt; connectors;\n};\n</code></pre>"},{"location":"components/connector/connector_manager/#purpose","title":"Purpose","text":"<ul> <li>Aggregate multiple exchange connectors and manage their startup and event forwarding.</li> </ul>"},{"location":"components/connector/connector_manager/#responsibilities","title":"Responsibilities","text":"Aspect Details Registration Stores connectors indexed by their <code>exchangeId()</code> value. Startup Calls <code>start()</code> on all registered connectors. Callbacks Wires trade and book update callbacks to each connector during startup. Output Logs startup of each connector to <code>stdout</code>."},{"location":"components/connector/connector_manager/#notes","title":"Notes","text":"<ul> <li>Assumes connectors are ready to start at the time of <code>startAll()</code> \u2014 no deferred registration.</li> <li>Wraps callbacks using lambdas to allow mutation and move-only semantics.</li> <li>Primarily intended for system bootstrap and orchestration; not used in performance-critical paths.</li> <li>Callback dispatch remains connector-local; manager only wires them once.</li> </ul>"},{"location":"components/connector/exchange_connector/","title":"ExchangeConnector","text":"<p><code>ExchangeConnector</code> is the abstract interface for real-time market data adapters. It provides lifecycle control and typed callback delivery for <code>BookUpdateEvent</code> and <code>TradeEvent</code>.</p> <pre><code>class ExchangeConnector {\npublic:\n  using BookUpdateCallback = std::move_only_function&lt;void(const BookUpdateEvent&amp;)&gt;;\n  using TradeCallback      = std::move_only_function&lt;void(const TradeEvent&amp;)&gt;;\n\n  virtual ~ExchangeConnector() = default;\n\n  virtual void start() = 0;\n  virtual void stop() = 0;\n\n  virtual std::string exchangeId() const = 0;\n\n  virtual void setCallbacks(BookUpdateCallback onBookUpdate, TradeCallback onTrade);\n\nprotected:\n  void emitBookUpdate(const BookUpdateEvent&amp; bu);\n  void emitTrade(const TradeEvent&amp; t);\n};\n</code></pre>"},{"location":"components/connector/exchange_connector/#purpose","title":"Purpose","text":"<ul> <li>Abstract base for all exchange-specific connectors (e.g. Bybit, Mock, Replay), handling event emission and lifecycle.</li> </ul>"},{"location":"components/connector/exchange_connector/#responsibilities","title":"Responsibilities","text":"Aspect Details Lifecycle <code>start()</code> and <code>stop()</code> control external connectivity and data flow. Identity <code>exchangeId()</code> provides a stable identifier for the connector instance. Callbacks <code>setCallbacks()</code> binds downstream handlers for book and trade events. Event Routing <code>emitBookUpdate()</code> and <code>emitTrade()</code> dispatch data to subscribers."},{"location":"components/connector/exchange_connector/#notes","title":"Notes","text":"<ul> <li>Callbacks use <code>std::move_only_function</code> to avoid <code>std::function</code> overhead and enable capturing closures with ownership.</li> <li>Implementations must call <code>emit*()</code> manually from internal processing (e.g. websocket handler).</li> <li>The class is intentionally non-copyable and non-thread-safe \u2014 connectors are expected to run in isolated threads.</li> </ul>"},{"location":"components/engine/abstract_market_data_subscriber/","title":"IMarketDataSubscriber","text":"<p><code>IMarketDataSubscriber</code> is a unified interface for components that consume real-time market data events. It supports optional handling of order book updates, trades, and candles.</p> <pre><code>class IMarketDataSubscriber : public ISubscriber {\npublic:\n  virtual ~IMarketDataSubscriber() = default;\n\n  virtual void onBookUpdate(const BookUpdateEvent&amp; ev) {}\n  virtual void onTrade(const TradeEvent&amp; ev) {}\n  virtual void onCandle(const CandleEvent&amp; ev) {}\n};\n</code></pre>"},{"location":"components/engine/abstract_market_data_subscriber/#purpose","title":"Purpose","text":"<ul> <li>Serve as a polymorphic listener for all market-facing event types across the system.</li> </ul>"},{"location":"components/engine/abstract_market_data_subscriber/#responsibilities","title":"Responsibilities","text":"Method Description onBookUpdate Receives <code>BookUpdateEvent</code> from <code>BookUpdateBus</code>. onTrade Receives <code>TradeEvent</code> from <code>TradeBus</code>. onCandle Receives <code>CandleEvent</code> from <code>CandleBus</code>."},{"location":"components/engine/abstract_market_data_subscriber/#notes","title":"Notes","text":"<ul> <li>Default implementations are no-ops \u2014 subscribers override only what they care about.</li> <li>Always used in conjunction with <code>EventBus&lt;T&gt;</code> and its <code>Policy</code> (sync or async).</li> <li>Inherits from <code>ISubscriber</code>, which provides <code>id()</code> and <code>mode()</code> for routing.</li> </ul>"},{"location":"components/engine/abstract_subscriber/","title":"ISubscriber","text":"<p><code>ISubscriber</code> defines the minimal interface for any component that consumes events via <code>EventBus</code>. It provides a stable identity and declares the delivery mode (push or pull).</p> <pre><code>struct ISubscriber {\n  virtual SubscriberId id() const = 0;\n  virtual SubscriberMode mode() const { return SubscriberMode::PUSH; }\n};\n\nusing SubscriberId = uint64_t;\nenum class SubscriberMode {\n  PUSH,\n  PULL\n};\n</code></pre>"},{"location":"components/engine/abstract_subscriber/#purpose","title":"Purpose","text":"<ul> <li>Abstract base for all event consumers, enabling uniform routing and delivery control.</li> </ul>"},{"location":"components/engine/abstract_subscriber/#responsibilities","title":"Responsibilities","text":"Method Description id() Returns a globally unique ID for this subscriber. mode() Declares delivery mode: <code>PUSH</code> (default) or <code>PULL</code> (manual drain)."},{"location":"components/engine/abstract_subscriber/#notes","title":"Notes","text":"<ul> <li><code>PUSH</code> mode: the bus invokes the subscriber immediately on event dispatch.</li> <li><code>PULL</code> mode: the subscriber drains from a queue explicitly (e.g., with batching).</li> <li><code>SubscriberId</code> is typically derived from pointer identity or hash \u2014 no strong ownership implied.</li> <li>Used by <code>EventBus&lt;T&gt;</code> to track subscribers and apply fan-out policy.</li> </ul>"},{"location":"components/engine/abstract_subsystem/","title":"ISubsystem","text":"<p><code>ISubsystem</code> defines a lifecycle interface for engine components that require explicit startup and shutdown phases.</p> <pre><code>class ISubsystem {\npublic:\n  virtual ~ISubsystem() = default;\n\n  virtual void start() = 0;\n  virtual void stop() = 0;\n};\n</code></pre>"},{"location":"components/engine/abstract_subsystem/#purpose","title":"Purpose","text":"<ul> <li>Provide deterministic initialization and teardown hooks for stateful modules in the system.</li> </ul>"},{"location":"components/engine/abstract_subsystem/#responsibilities","title":"Responsibilities","text":"Method Description start Called during engine bootstrapping. stop Called during shutdown or reset."},{"location":"components/engine/abstract_subsystem/#notes","title":"Notes","text":"<ul> <li>Used by core modules like <code>CandleAggregator</code>, <code>Strategy</code>, <code>ExecutionTracker</code>, etc.</li> <li>Lifecycle is typically orchestrated by the engine or test harness.</li> <li>No assumptions about threading \u2014 start/stop are always externally coordinated.</li> </ul>"},{"location":"components/engine/engine/","title":"Engine","text":"<p><code>Engine</code> coordinates the startup and shutdown of the entire trading system. It owns the engine configuration, all exchange connectors, and system subsystems.</p> <pre><code>class Engine : public ISubsystem {\npublic:\n  Engine(const EngineConfig&amp; config,\n         std::vector&lt;std::unique_ptr&lt;ISubsystem&gt;&gt; subsystems,\n         std::vector&lt;std::shared_ptr&lt;ExchangeConnector&gt;&gt; connectors);\n\n  void start() override;\n  void stop() override;\n};\n</code></pre>"},{"location":"components/engine/engine/#purpose","title":"Purpose","text":"<ul> <li>Central orchestration unit responsible for lifecycle management of all core components.</li> </ul>"},{"location":"components/engine/engine/#responsibilities","title":"Responsibilities","text":"Aspect Description Configuration Stores full <code>EngineConfig</code> used by subsystems and connectors. Subsystems Owns and manages startup/teardown of all registered <code>ISubsystem</code>s. Connectors Retains exchange adapters to prevent premature destruction."},{"location":"components/engine/engine/#exchangeinstance","title":"ExchangeInstance","text":"<pre><code>struct ExchangeInstance {\n  std::string exchangeType;\n  std::string name;\n  std::string symbol;\n  std::shared_ptr&lt;ExchangeConnector&gt; connector;\n};\n</code></pre> Field Description exchangeType Registered type used in factory resolution. name User-defined alias for logging or mapping. symbol Symbol string for routing or filtering. connector Pointer to live exchange connection."},{"location":"components/engine/engine/#notes","title":"Notes","text":"<ul> <li><code>start()</code>/<code>stop()</code> invoke lifecycle methods on all subsystems in the order defined.</li> <li>All subsystems are owned via <code>unique_ptr</code>; destruction is deterministic and ordered.</li> <li>Designed to decouple bootstrapping logic from component logic \u2014 the <code>Engine</code> is not involved in runtime signal or data flow.</li> </ul>"},{"location":"components/engine/engine_config/","title":"EngineConfig","text":"<p><code>EngineConfig</code> holds top-level runtime configuration for the trading engine, including exchange definitions, kill switch limits, and logging preferences.</p> <pre><code>struct EngineConfig {\n  std::vector&lt;ExchangeConfig&gt; exchanges;\n  KillSwitchConfig killSwitchConfig;\n  std::string logLevel = \"info\";\n  std::string logFile;\n};\n</code></pre>"},{"location":"components/engine/engine_config/#purpose","title":"Purpose","text":"<ul> <li>Aggregate all user-specified engine parameters into a single loadable structure.</li> </ul>"},{"location":"components/engine/engine_config/#responsibilities","title":"Responsibilities","text":"Field Description exchanges List of exchanges and symbols to connect (via <code>ExchangeConfig</code>). killSwitchConfig Limits for order size, frequency, and loss (see <code>KillSwitchConfig</code>). logLevel Runtime log verbosity (<code>info</code>, <code>debug</code>, <code>trace</code>, etc.). logFile Optional path to write logs to disk."},{"location":"components/engine/engine_config/#substructures","title":"Substructures","text":""},{"location":"components/engine/engine_config/#exchangeconfig","title":"<code>ExchangeConfig</code>","text":"Field Description name Display name or label (e.g. <code>\"Bybit\"</code>). type Connector type (used by <code>ConnectorFactory</code>). symbols List of <code>SymbolConfig</code> entries."},{"location":"components/engine/engine_config/#symbolconfig","title":"<code>SymbolConfig</code>","text":"Field Description symbol Symbol name (e.g. <code>\"DOTUSDT\"</code>). tickSize Price resolution used by the order book. expectedDeviation Max allowed distance from center price."},{"location":"components/engine/engine_config/#killswitchconfig","title":"<code>KillSwitchConfig</code>","text":"Field Description maxOrderQty Per-order size limit. maxLoss Hard loss cap per session. maxOrdersPerSecond Throttling limit for message rate (\u2264 0 = disabled)."},{"location":"components/engine/engine_config/#notes","title":"Notes","text":"<ul> <li>Typically loaded from JSON during engine bootstrap.</li> <li>Used by multiple components: symbol registry, kill switch, connector setup, and logging.</li> </ul>"},{"location":"components/engine/event_dispatcher/","title":"EventDispatcher","text":"<p><code>EventDispatcher&lt;T&gt;</code> provides a compile-time dispatch mechanism that routes events to the appropriate subscriber method without relying on virtual functions or dynamic casting.</p> <pre><code>template &lt;typename T&gt;\nstruct EventDispatcher;\n\ntemplate &lt;typename T&gt;\nstruct EventDispatcher&lt;pool::Handle&lt;T&gt;&gt; {\n  static void dispatch(const pool::Handle&lt;T&gt;&amp; ev, typename T::Listener&amp; sub);\n};\n\n// Specializations for each event type...\n</code></pre>"},{"location":"components/engine/event_dispatcher/#purpose","title":"Purpose","text":"<ul> <li>Deliver strongly-typed events (<code>BookUpdateEvent</code>, <code>TradeEvent</code>, etc.) to their matching handler methods on subscribers, using static dispatch.</li> </ul>"},{"location":"components/engine/event_dispatcher/#responsibilities","title":"Responsibilities","text":"Specialization Routed To <code>BookUpdateEvent</code> <code>IMarketDataSubscriber::onBookUpdate()</code> <code>TradeEvent</code> <code>IMarketDataSubscriber::onTrade()</code> <code>CandleEvent</code> <code>IMarketDataSubscriber::onCandle()</code> <code>OrderEvent</code> <code>IOrderExecutionListener::onOrderFilled()</code> via <code>dispatchTo()</code> <code>pool::Handle&lt;T&gt;</code> Unwraps and forwards to <code>EventDispatcher&lt;T&gt;</code>"},{"location":"components/engine/event_dispatcher/#notes","title":"Notes","text":"<ul> <li>Eliminates virtual overhead in <code>EventBus</code> by avoiding <code>event-&gt;dispatchTo()</code> directly.</li> <li>Pooled events (<code>pool::Handle&lt;T&gt;</code>) are transparently unwrapped and dispatched.</li> <li>Extensible \u2014 any new event type must define a matching specialization.</li> <li>Dispatch is strictly type-safe and resolved at compile time.</li> </ul>"},{"location":"components/engine/symbol_registry/","title":"SymbolRegistry","text":"<p><code>SymbolRegistry</code> assigns and resolves stable <code>SymbolId</code> values for <code>(exchange, symbol)</code> pairs. It enables compact, integer-based symbol references throughout the engine.</p> <pre><code>class SymbolRegistry {\npublic:\n  SymbolId registerSymbol(const std::string&amp; exchange, const std::string&amp; symbol);\n  std::optional&lt;SymbolId&gt; getSymbolId(const std::string&amp; exchange, const std::string&amp; symbol) const;\n  std::pair&lt;std::string, std::string&gt; getSymbolName(SymbolId id) const;\n\nprivate:\n  std::unordered_map&lt;std::string, SymbolId&gt; _map;\n  std::vector&lt;std::pair&lt;std::string, std::string&gt;&gt; _reverse;\n  mutable std::mutex _mutex;\n};\n</code></pre>"},{"location":"components/engine/symbol_registry/#purpose","title":"Purpose","text":"<ul> <li>Provide a fast, thread-safe mapping between human-readable <code>(exchange, symbol)</code> and numeric <code>SymbolId</code>.</li> </ul>"},{"location":"components/engine/symbol_registry/#responsibilities","title":"Responsibilities","text":"Method Description <code>registerSymbol</code> Assigns a new <code>SymbolId</code> if not already registered. <code>getSymbolId</code> Returns the <code>SymbolId</code> for a given <code>(exchange, symbol)</code>. <code>getSymbolName</code> Resolves a <code>SymbolId</code> back to <code>(exchange, symbol)</code> string pair."},{"location":"components/engine/symbol_registry/#internal-design","title":"Internal Design","text":"<ul> <li><code>_map</code> uses a composite string key: <code>\"exchange:symbol\" \u2192 SymbolId</code>.</li> <li><code>_reverse</code> holds a parallel vector of <code>(exchange, symbol)</code> for reverse lookup.</li> <li>All methods are guarded by a single mutex for thread safety.</li> </ul>"},{"location":"components/engine/symbol_registry/#notes","title":"Notes","text":"<ul> <li>Used by all market data components to route and normalize per-symbol state.</li> <li><code>SymbolId</code> is a dense, zero-based <code>uint32_t</code>, suitable for array indexing.</li> <li>Forward and reverse lookups are both O(1) and memory-efficient.</li> </ul>"},{"location":"components/engine/tick_barrier/","title":"TickBarrier","text":"<p><code>TickBarrier</code> is a lightweight synchronization primitive used to coordinate a fixed number of consumers during synchronous tick processing. It enables deterministic progression to the next event only after all subscribers have completed processing.</p> <pre><code>class TickBarrier {\npublic:\n  explicit TickBarrier(size_t total);\n\n  void complete();\n  void wait();\n\nprivate:\n  const size_t _total;\n  std::atomic&lt;size_t&gt; _completed;\n};\n</code></pre>"},{"location":"components/engine/tick_barrier/#purpose","title":"Purpose","text":"<ul> <li>Synchronize fan-out consumers in <code>SyncPolicy</code> to ensure all subscribers complete before the next tick is published.</li> </ul>"},{"location":"components/engine/tick_barrier/#responsibilities","title":"Responsibilities","text":"Method Description complete Called by each subscriber when it finishes processing a tick. wait Blocks until all expected completions have been received."},{"location":"components/engine/tick_barrier/#notes","title":"Notes","text":"<ul> <li>Spin-waiting via <code>std::this_thread::yield()</code> \u2014 no locks, no condition variables.</li> <li>Suitable only for short-lived, low-latency operations (e.g., simulation/batch replay).</li> <li>Initialized with <code>total</code> \u2014 the number of expected <code>complete()</code> calls per tick.</li> <li>Not reusable \u2014 one barrier per tick. Resetting requires re-instantiation.</li> </ul>"},{"location":"components/engine/tick_guard/","title":"TickGuard","text":"<p><code>TickGuard</code> is a RAII helper that automatically signals completion to a <code>TickBarrier</code> when it goes out of scope. It ensures deterministic tick completion even in the presence of early returns or exceptions.</p> <pre><code>class TickGuard {\npublic:\n  explicit TickGuard(TickBarrier&amp; barrier);\n  ~TickGuard();\n\n  TickGuard(const TickGuard&amp;) = delete;\n  TickGuard&amp; operator=(const TickGuard&amp;) = delete;\n\nprivate:\n  TickBarrier* _barrier;\n};\n</code></pre>"},{"location":"components/engine/tick_guard/#purpose","title":"Purpose","text":"<ul> <li>Guarantee that <code>TickBarrier::complete()</code> is called once per subscriber at the end of a tick, regardless of control flow.</li> </ul>"},{"location":"components/engine/tick_guard/#responsibilities","title":"Responsibilities","text":"Behavior Description Construction Stores reference to <code>TickBarrier</code>. Destruction Calls <code>complete()</code> when the guard is destroyed. Copy/Move Explicitly non-copyable and non-movable."},{"location":"components/engine/tick_guard/#notes","title":"Notes","text":"<ul> <li>Should be declared at the top of the subscriber's <code>onEvent()</code> method in <code>SyncPolicy</code>.</li> <li>Ensures that even early returns or exceptions do not break barrier synchronization.</li> <li>No runtime cost beyond pointer storage and destructor call.</li> </ul>"},{"location":"components/execution/abstract_execution_listener/","title":"IOrderExecutionListener","text":"<p><code>IOrderExecutionListener</code> defines the interface for components that react to order lifecycle events. It is used by <code>OrderExecutionBus</code> to notify subscribers of changes in order state.</p> <pre><code>class IOrderExecutionListener : public ISubscriber {\npublic:\n  explicit IOrderExecutionListener(SubscriberId id);\n  virtual ~IOrderExecutionListener() = default;\n\n  SubscriberId id() const override;\n\n  virtual void onOrderSubmitted(const Order&amp; order) = 0;\n  virtual void onOrderAccepted(const Order&amp; order) = 0;\n  virtual void onOrderPartiallyFilled(const Order&amp; order, Quantity fillQty) = 0;\n  virtual void onOrderFilled(const Order&amp; order) = 0;\n  virtual void onOrderCanceled(const Order&amp; order) = 0;\n  virtual void onOrderExpired(const Order&amp; order) = 0;\n  virtual void onOrderRejected(const Order&amp; order, const std::string&amp; reason) = 0;\n  virtual void onOrderReplaced(const Order&amp; oldOrder, const Order&amp; newOrder) = 0;\n};\n</code></pre>"},{"location":"components/execution/abstract_execution_listener/#purpose","title":"Purpose","text":"<ul> <li>Provide a type-safe listener interface for receiving detailed updates on order status transitions.</li> </ul>"},{"location":"components/execution/abstract_execution_listener/#responsibilities","title":"Responsibilities","text":"Method Triggered On <code>onOrderSubmitted</code> Order submitted to venue or simulator. <code>onOrderAccepted</code> Order acknowledged/accepted by the exchange. <code>onOrderPartiallyFilled</code> Partial fill received; includes fill quantity. <code>onOrderFilled</code> Fully filled. <code>onOrderCanceled</code> Canceled by user or system. <code>onOrderExpired</code> Expired due to time-in-force or system conditions. <code>onOrderRejected</code> Rejected by exchange or risk engine (with reason). <code>onOrderReplaced</code> Order was replaced with a new one."},{"location":"components/execution/abstract_execution_listener/#notes","title":"Notes","text":"<ul> <li>Each listener is identified via a stable <code>SubscriberId</code>.</li> <li>Used in tandem with <code>OrderEvent::dispatchTo()</code> to decouple producers from listeners.</li> <li>Implemented by components such as <code>PositionManager</code>, <code>ExecutionTracker</code>, and metrics/reporting modules.</li> </ul>"},{"location":"components/execution/abstract_executor/","title":"IOrderExecutor","text":"<p><code>IOrderExecutor</code> defines the interface for components responsible for submitting, canceling, and replacing orders. It acts as the execution gateway in both simulated and live environments.</p> <pre><code>class IOrderExecutor : public ISubsystem {\npublic:\n  virtual ~IOrderExecutor() = default;\n\n  virtual void submitOrder(const Order&amp; order) {};\n  virtual void cancelOrder(OrderId orderId) {};\n  virtual void replaceOrder(OrderId oldOrderId, const Order&amp; newOrder) {};\n};\n</code></pre>"},{"location":"components/execution/abstract_executor/#purpose","title":"Purpose","text":"<ul> <li>Abstract execution interface used by strategies and internal components to place and manage orders.</li> </ul>"},{"location":"components/execution/abstract_executor/#responsibilities","title":"Responsibilities","text":"Method Description <code>submitOrder</code> Sends a new order to the execution venue or simulator. <code>cancelOrder</code> Cancels a previously submitted order. <code>replaceOrder</code> Replaces an existing order with new parameters."},{"location":"components/execution/abstract_executor/#notes","title":"Notes","text":"<ul> <li>Implements <code>ISubsystem</code>, enabling lifecycle coordination via <code>start()</code> and <code>stop()</code>.</li> <li>Can be backed by mocks, simulators, or real exchange adapters.</li> <li>Actual routing and fill simulation logic resides in concrete subclasses.</li> </ul>"},{"location":"components/execution/execution_tracker_adapter/","title":"ExecutionTrackerAdapter","text":"<p><code>ExecutionTrackerAdapter</code> is a proxy that forwards order execution events to an <code>IExecutionTracker</code>, timestamping each transition with <code>steady_clock::now()</code>.</p> <pre><code>class ExecutionTrackerAdapter : public IOrderExecutionListener {\npublic:\n  ExecutionTrackerAdapter(SubscriberId id, IExecutionTracker* tracker);\n  // All IOrderExecutionListener methods overridden\nprivate:\n  IExecutionTracker* _tracker;\n};\n</code></pre>"},{"location":"components/execution/execution_tracker_adapter/#purpose","title":"Purpose","text":"<ul> <li>Decouple execution tracking logic from the event delivery mechanism by timestamping and delegating events to a metrics recorder.</li> </ul>"},{"location":"components/execution/execution_tracker_adapter/#responsibilities","title":"Responsibilities","text":"Method Delegated To <code>onOrderSubmitted</code> <code>_tracker-&gt;onOrderSubmitted(..., now)</code> <code>onOrderAccepted</code> <code>_tracker-&gt;onOrderAccepted(..., now)</code> <code>onOrderPartiallyFilled</code> <code>_tracker-&gt;onOrderPartiallyFilled(..., now)</code> <code>onOrderFilled</code> <code>_tracker-&gt;onOrderFilled(..., now)</code> <code>onOrderCanceled</code> <code>_tracker-&gt;onOrderCanceled(..., now)</code> <code>onOrderExpired</code> <code>_tracker-&gt;onOrderExpired(..., now)</code> <code>onOrderRejected</code> <code>_tracker-&gt;onOrderRejected(..., now)</code> <code>onOrderReplaced</code> <code>_tracker-&gt;onOrderReplaced(..., now)</code>"},{"location":"components/execution/execution_tracker_adapter/#notes","title":"Notes","text":"<ul> <li>Uses wall-clock <code>std::chrono::steady_clock::now()</code> to consistently timestamp all events.</li> <li>The adapter does not own the <code>IExecutionTracker</code>; it assumes external lifetime management.</li> <li>Enables clean separation of metrics collection from trading logic.</li> </ul>"},{"location":"components/execution/multi_execution_listener/","title":"MultiExecutionListener","text":"<p><code>MultiExecutionListener</code> fans out order lifecycle events to multiple <code>IOrderExecutionListener</code> targets. It acts as a multicast adapter for <code>OrderExecutionBus</code> subscribers.</p> <pre><code>class MultiExecutionListener : public IOrderExecutionListener {\npublic:\n  explicit MultiExecutionListener(SubscriberId id);\n  void addListener(IOrderExecutionListener* listener);\n\n  // All event methods delegate to added listeners\n};\n</code></pre>"},{"location":"components/execution/multi_execution_listener/#purpose","title":"Purpose","text":"<ul> <li>Aggregate multiple execution listeners into a single subscriber to avoid duplicating subscriptions to the <code>OrderExecutionBus</code>.</li> </ul>"},{"location":"components/execution/multi_execution_listener/#responsibilities","title":"Responsibilities","text":"Method Behavior <code>addListener()</code> Registers a new listener (if not already added). Event handlers Forwards all events to each registered listener."},{"location":"components/execution/multi_execution_listener/#notes","title":"Notes","text":"<ul> <li>Listeners are stored as raw pointers; ownership is not transferred.</li> <li>Prevents duplicate listeners using <code>std::ranges::find()</code>.</li> <li>Efficient for use cases like simultaneously tracking PnL, latency, and order audit logs.</li> </ul>"},{"location":"components/execution/order/","title":"Order","text":"<p><code>Order</code> encapsulates all information related to a client-side order, including identifiers, execution parameters, status, and timestamps.</p> <pre><code>struct Order {\n  OrderId id{};\n  Side side{};\n  Price price{};\n  Quantity quantity{};\n  OrderType type{};\n  SymbolId symbol{};\n\n  OrderStatus status = OrderStatus::NEW;\n  Quantity filledQuantity{0};\n\n  std::chrono::steady_clock::time_point createdAt{};\n  std::optional&lt;std::chrono::steady_clock::time_point&gt; exchangeTimestamp;\n  std::optional&lt;std::chrono::steady_clock::time_point&gt; lastUpdated;\n  std::optional&lt;std::chrono::steady_clock::time_point&gt; expiresAfter;\n};\n</code></pre>"},{"location":"components/execution/order/#purpose","title":"Purpose","text":"<ul> <li>Represent an order's full lifecycle \u2014 from submission to final state \u2014 including fill progress, exchange timestamps, and status.</li> </ul>"},{"location":"components/execution/order/#responsibilities","title":"Responsibilities","text":"Field Description id Globally unique order identifier. side Buy or sell. price Limit price; ignored for market orders. quantity Total order size in base units. type <code>LIMIT</code>, <code>MARKET</code>, or other engine-defined types. symbol Compact numeric symbol reference (<code>SymbolId</code>). status Current order status (see <code>OrderStatus</code>). filledQuantity Accumulated quantity filled so far. createdAt Local creation timestamp. exchangeTimestamp When the exchange acknowledged the order (if applicable). lastUpdated Timestamp of last known state transition. expiresAfter Optional expiry deadline (e.g. for IOC/GTC enforcement)."},{"location":"components/execution/order/#notes","title":"Notes","text":"<ul> <li>Used as the payload in <code>OrderEvent</code> messages.</li> <li>All timestamps are based on <code>steady_clock</code> for monotonic sequencing.</li> <li>Immutable once submitted; all updates produce new events and/or replacement orders.</li> </ul>"},{"location":"components/execution/bus/order_execution_bus/","title":"OrderExecutionBus","text":"<p><code>OrderExecutionBus</code> is the delivery channel for <code>OrderEvent</code> messages, used to notify downstream components (e.g. PnL trackers, position managers) about order lifecycle events.</p> <pre><code>#ifdef USE_SYNC_ORDER_BUS\nusing OrderExecutionBus = EventBus&lt;OrderEvent, SyncPolicy&lt;OrderEvent&gt;&gt;;\n#else\nusing OrderExecutionBus = EventBus&lt;OrderEvent, AsyncPolicy&lt;OrderEvent&gt;&gt;;\n#endif\n</code></pre>"},{"location":"components/execution/bus/order_execution_bus/#purpose","title":"Purpose","text":"<ul> <li>Fan-out dispatch of <code>OrderEvent</code>s to registered execution listeners with selectable sync/async policy.</li> </ul>"},{"location":"components/execution/bus/order_execution_bus/#responsibilities","title":"Responsibilities","text":"Aspect Description Payload Transports <code>OrderEvent</code> instances directly (no pooling). Mode Toggled via <code>USE_SYNC_ORDER_BUS</code> macro at compile time. Usage Used to notify components like <code>PositionManager</code>, <code>PnLTracker</code>, etc."},{"location":"components/execution/bus/order_execution_bus/#notes","title":"Notes","text":"<ul> <li><code>SyncPolicy</code> ensures deterministic propagation \u2014 used in simulation/test environments.</li> <li><code>AsyncPolicy</code> favors latency and throughput \u2014 suitable for production execution.</li> <li>Dispatch is resolved via <code>EventDispatcher&lt;OrderEvent&gt;</code>, which calls <code>dispatchTo(listener)</code>.</li> </ul>"},{"location":"components/execution/events/order_event/","title":"OrderEvent","text":"<p><code>OrderEvent</code> encapsulates a single order lifecycle transition and delivers it to components via <code>OrderExecutionBus</code>.</p> <pre><code>struct OrderEvent {\n  using Listener = IOrderExecutionListener;\n\n  OrderEventType type{};\n  Order order{};\n  Order newOrder{};\n  Quantity fillQty{0};\n  uint64_t tickSequence = 0;\n\n  void dispatchTo(IOrderExecutionListener&amp; listener) const;\n};\n</code></pre>"},{"location":"components/execution/events/order_event/#purpose","title":"Purpose","text":"<ul> <li>Represent and route order state changes (submission, fills, cancelation, etc.) to execution listeners.</li> </ul>"},{"location":"components/execution/events/order_event/#responsibilities","title":"Responsibilities","text":"Field Description type Event type \u2014 one of <code>SUBMITTED</code>, <code>FILLED</code>, <code>REPLACED</code>, etc. order The primary order involved in the event. newOrder Used only for <code>REPLACED</code> events. fillQty Quantity filled (used only in <code>PARTIALLY_FILLED</code>). tickSequence Event ordering marker for sequencing and backtesting."},{"location":"components/execution/events/order_event/#dispatch-logic","title":"Dispatch Logic","text":"<pre><code>void dispatchTo(IOrderExecutionListener&amp; listener) const;\n</code></pre> <p>Routes the event to the appropriate method:</p> Type Dispatched Method <code>SUBMITTED</code> <code>onOrderSubmitted(order)</code> <code>ACCEPTED</code> <code>onOrderAccepted(order)</code> <code>PARTIALLY_FILLED</code> <code>onOrderPartiallyFilled(order, fillQty)</code> <code>FILLED</code> <code>onOrderFilled(order)</code> <code>CANCELED</code> <code>onOrderCanceled(order)</code> <code>EXPIRED</code> <code>onOrderExpired(order)</code> <code>REJECTED</code> <code>onOrderRejected(order, /*reason*/ \"\")</code> <code>REPLACED</code> <code>onOrderReplaced(order, newOrder)</code>"},{"location":"components/execution/events/order_event/#notes","title":"Notes","text":"<ul> <li>Dispatch is type-safe and static \u2014 no RTTI or dynamic casts.</li> <li><code>tickSequence</code> ensures global ordering consistency across mixed event streams.</li> <li>Used by <code>EventBus&lt;OrderEvent, *&gt;</code> and delivered to <code>IOrderExecutionListener</code> implementations.</li> </ul>"},{"location":"components/killswitch/abstract_killswitch/","title":"IKillSwitch","text":"<p><code>IKillSwitch</code> defines the interface for components that enforce emergency shutdown conditions in the trading system, typically in response to loss limits, excessive order flow, or abnormal conditions.</p> <pre><code>class IKillSwitch : public ISubsystem {\npublic:\n  virtual ~IKillSwitch() = default;\n\n  virtual void check(const Order&amp; order) = 0;\n  virtual void trigger(const std::string&amp; reason) = 0;\n  virtual bool isTriggered() const = 0;\n  virtual std::string reason() const = 0;\n};\n</code></pre>"},{"location":"components/killswitch/abstract_killswitch/#purpose","title":"Purpose","text":"<ul> <li>Provide runtime protection against runaway strategies, loss accumulation, or systemic failures by halting all trading activity.</li> </ul>"},{"location":"components/killswitch/abstract_killswitch/#responsibilities","title":"Responsibilities","text":"Method Description <code>check(order)</code> Evaluates the incoming order against risk limits. <code>trigger()</code> Manually activates the kill switch with a reason string. <code>isTriggered()</code> Returns whether the kill switch is currently active. <code>reason()</code> Returns the human-readable cause of activation."},{"location":"components/killswitch/abstract_killswitch/#notes","title":"Notes","text":"<ul> <li>Implements <code>ISubsystem</code>, allowing coordinated startup and reset across engine lifecycle.</li> <li>Can be wired into strategy layer, order executor, or global event loop.</li> <li>Once triggered, downstream components are expected to halt order submission and processing.</li> </ul>"},{"location":"components/metrics/abstract_execution_tracker/","title":"IExecutionTracker","text":"<p><code>IExecutionTracker</code> defines an interface for tracking order lifecycle events with precise timestamps. It is typically used for latency analysis, logging, and performance metrics.</p> <pre><code>class IExecutionTracker : public ISubsystem {\npublic:\n  virtual ~IExecutionTracker() = default;\n\n  virtual void onOrderSubmitted(const Order&amp; order, std::chrono::steady_clock::time_point ts) = 0;\n  virtual void onOrderAccepted(const Order&amp; order, std::chrono::steady_clock::time_point ts) = 0;\n  virtual void onOrderPartiallyFilled(const Order&amp; order, Quantity fillQty, std::chrono::steady_clock::time_point ts) = 0;\n  virtual void onOrderFilled(const Order&amp; order, std::chrono::steady_clock::time_point ts) = 0;\n  virtual void onOrderCanceled(const Order&amp; order, std::chrono::steady_clock::time_point ts) = 0;\n  virtual void onOrderExpired(const Order&amp; order, std::chrono::steady_clock::time_point ts) = 0;\n  virtual void onOrderRejected(const Order&amp; order, const std::string&amp; reason, std::chrono::steady_clock::time_point ts) = 0;\n  virtual void onOrderReplaced(const Order&amp; oldOrder, const Order&amp; newOrder, std::chrono::steady_clock::time_point ts) = 0;\n};\n</code></pre>"},{"location":"components/metrics/abstract_execution_tracker/#purpose","title":"Purpose","text":"<ul> <li>Capture precise timing of each order state transition for performance diagnostics and post-trade analysis.</li> </ul>"},{"location":"components/metrics/abstract_execution_tracker/#responsibilities","title":"Responsibilities","text":"Method Captures <code>onOrderSubmitted</code> Time of initial submission. <code>onOrderAccepted</code> Time acknowledged by exchange or venue. <code>onOrderPartiallyFilled</code> Time of partial fill, including filled quantity. <code>onOrderFilled</code> Time of full fill. <code>onOrderCanceled</code> Time of cancel confirmation. <code>onOrderExpired</code> Time the order was marked as expired. <code>onOrderRejected</code> Time of rejection, including optional reason. <code>onOrderReplaced</code> Time of order replacement, with reference to both old and new."},{"location":"components/metrics/abstract_execution_tracker/#notes","title":"Notes","text":"<ul> <li>All timestamps are provided externally (usually by <code>ExecutionTrackerAdapter</code>) to ensure consistency.</li> <li>Used in simulations and live systems for detailed latency tracking and event sequencing.</li> <li>Inherits from <code>ISubsystem</code> for lifecycle integration with the engine.</li> </ul>"},{"location":"components/metrics/abstract_pnl_tracker/","title":"IPnLTracker","text":"<p><code>IPnLTracker</code> defines a minimal interface for tracking realized and unrealized profit and loss (PnL) based on filled orders.</p> <pre><code>class IPnLTracker : public ISubsystem {\npublic:\n  virtual ~IPnLTracker() = default;\n  virtual void onOrderFilled(const Order&amp; order) = 0;\n};\n</code></pre>"},{"location":"components/metrics/abstract_pnl_tracker/#purpose","title":"Purpose","text":"<ul> <li>Record and update PnL metrics in response to order fill events.</li> </ul>"},{"location":"components/metrics/abstract_pnl_tracker/#responsibilities","title":"Responsibilities","text":"Method Description <code>onOrderFilled</code> Called when an order is fully filled; updates PnL."},{"location":"components/metrics/abstract_pnl_tracker/#notes","title":"Notes","text":"<ul> <li>Invoked only on complete fills \u2014 partial fills should be handled at a higher level if needed.</li> <li>Used in both real-time and simulation modes to compute performance metrics.</li> <li>Inherits from <code>ISubsystem</code> for coordinated lifecycle management.</li> </ul>"},{"location":"components/position/abstract_position_manager/","title":"IPositionManager","text":"<p><code>IPositionManager</code> maintains real-time position tracking per symbol and reacts to all order execution events. It is a core component for portfolio state management in both live trading and simulation.</p> <pre><code>class IPositionManager : public ISubsystem, public IOrderExecutionListener {\npublic:\n  explicit IPositionManager(SubscriberId id);\n  virtual ~IPositionManager() = default;\n\n  virtual Quantity getPosition(SymbolId symbol) const = 0;\n};\n</code></pre>"},{"location":"components/position/abstract_position_manager/#purpose","title":"Purpose","text":"<ul> <li>Track and expose current position sizes for all traded instruments in response to order events.</li> </ul>"},{"location":"components/position/abstract_position_manager/#responsibilities","title":"Responsibilities","text":"Method Description <code>getPosition()</code> Returns net position (long/short/flat) for a given <code>SymbolId</code>. Execution events Inherited from <code>IOrderExecutionListener</code> \u2014 updates position on <code>FILLED</code>, <code>REPLACED</code>, etc."},{"location":"components/position/abstract_position_manager/#notes","title":"Notes","text":"<ul> <li>Acts as a persistent state store for strategies, risk systems, and reporting.</li> <li>Must be registered with <code>OrderExecutionBus</code> to receive fill and cancel notifications.</li> <li>Can optionally implement position limits or exposure constraints internally.</li> </ul>"},{"location":"components/risk/abstract_risk_manager/","title":"IRiskManager","text":"<p><code>IRiskManager</code> defines an interface for validating whether a given order complies with system-defined risk constraints before it is submitted.</p> <pre><code>class IRiskManager : public ISubsystem {\npublic:\n  virtual ~IRiskManager() = default;\n  virtual bool allow(const Order&amp; order) const = 0;\n};\n</code></pre>"},{"location":"components/risk/abstract_risk_manager/#purpose","title":"Purpose","text":"<ul> <li>Enforce pre-trade risk checks such as size limits, leverage rules, or order throttling.</li> </ul>"},{"location":"components/risk/abstract_risk_manager/#responsibilities","title":"Responsibilities","text":"Method Description <code>allow()</code> Returns <code>true</code> if the order is permitted to proceed."},{"location":"components/risk/abstract_risk_manager/#notes","title":"Notes","text":"<ul> <li>Called by strategy or execution layer before submitting an order.</li> <li>Stateless implementations may rely solely on order parameters; stateful variants may track recent flow.</li> <li>Integrated into the engine via <code>ISubsystem</code> for unified startup and reset behavior.</li> </ul>"},{"location":"components/sink/abstract_storage_sink/","title":"IStorageSink","text":"<p><code>IStorageSink</code> defines the interface for persisting executed orders and related trading data. It abstracts away the underlying storage mechanism (e.g. MongoDB, binary log, cloud).</p> <pre><code>class IStorageSink : public ISubsystem {\npublic:\n  virtual ~IStorageSink() = default;\n  virtual void store(const Order&amp; order) = 0;\n};\n</code></pre>"},{"location":"components/sink/abstract_storage_sink/#purpose","title":"Purpose","text":"<ul> <li>Persist orders for post-trade audit, reconciliation, analytics, or compliance.</li> </ul>"},{"location":"components/sink/abstract_storage_sink/#responsibilities","title":"Responsibilities","text":"Method Description <code>store</code> Persists the provided <code>Order</code> object."},{"location":"components/sink/abstract_storage_sink/#notes","title":"Notes","text":"<ul> <li>Called when orders are filled, canceled, or otherwise finalized.</li> <li>Backends may include MongoDB, file-based logs, or in-memory mirrors.</li> <li>Integrated via <code>ISubsystem</code> for lifecycle control and flush handling.</li> </ul>"},{"location":"components/strategy/abstract_strategy/","title":"IStrategy","text":"<p><code>IStrategy</code> defines the interface for all trading strategies. It combines market data subscription and subsystem lifecycle control, serving as the main driver of signal generation and order placement.</p> <pre><code>class IStrategy : public ISubsystem, public IMarketDataSubscriber {\npublic:\n  virtual ~IStrategy() = default;\n};\n</code></pre>"},{"location":"components/strategy/abstract_strategy/#purpose","title":"Purpose","text":"<ul> <li>Represent a trading strategy that reacts to market data and drives execution decisions.</li> </ul>"},{"location":"components/strategy/abstract_strategy/#composition","title":"Composition","text":"Inherits From Responsibilities <code>IMarketDataSubscriber</code> Receives <code>TradeEvent</code>, <code>BookUpdateEvent</code>, <code>CandleEvent</code>. <code>ISubsystem</code> Enables coordinated <code>start()</code> / <code>stop()</code> during engine run."},{"location":"components/strategy/abstract_strategy/#notes","title":"Notes","text":"<ul> <li>Strategies are typically registered as subscribers to market data buses.</li> <li>Lifecycle hooks (<code>start</code>, <code>stop</code>) are used for setup, parameter resets, or cleanup.</li> <li>Strategies are expected to emit orders via <code>IOrderExecutor</code>, respecting <code>IRiskManager</code> and <code>IKillSwitch</code> constraints.</li> </ul>"},{"location":"components/util/base/decimal/","title":"Decimal","text":"<p><code>Decimal</code> is a fixed-point arithmetic wrapper designed for performance-critical environments such as HFT. It provides type-safe arithmetic on scaled integers with configurable tick precision and compile-time guarantees.</p> <pre><code>template &lt;typename Tag, int Scale, int64_t TickSize = 1&gt;\nclass Decimal {\n  // ...\n};\n</code></pre>"},{"location":"components/util/base/decimal/#purpose","title":"Purpose","text":"<ul> <li>Avoid floating-point rounding errors by using integer math with fixed scaling.</li> <li>Provide clean, zero-cost abstractions for price/quantity units with compile-time type safety.</li> </ul>"},{"location":"components/util/base/decimal/#parameters","title":"Parameters","text":"Template Param Description <code>Tag</code> Phantom type used to disambiguate unit domains (e.g. <code>Price</code>, <code>Qty</code>). <code>Scale</code> Number of sub-units per whole unit (e.g. 1000 = 3 decimal places). <code>TickSize</code> Granularity for tick-based rounding."},{"location":"components/util/base/decimal/#key-features","title":"Key Features","text":"Function Description <code>fromDouble(double)</code> Converts a floating-point value to scaled integer with rounding. <code>toDouble()</code> Converts internal <code>_raw</code> value to <code>double</code> for logging/debugging. <code>raw()</code> Returns raw internal <code>int64_t</code> value. <code>roundToTick()</code> Rounds to the nearest multiple of <code>TickSize</code>. <code>isZero()</code> True if <code>_raw == 0</code>. Arithmetic / Comparison Ops Full suite of <code>+</code>, <code>-</code>, <code>*</code>, <code>/</code>, <code>==</code>, <code>&lt;</code>, <code>&lt;=</code>, etc. on same-type values."},{"location":"components/util/base/decimal/#notes","title":"Notes","text":"<ul> <li>Scale is enforced at compile time \u2014 <code>Decimal&lt;PriceTag, 1000&gt;</code> is a distinct type from <code>Decimal&lt;QuantityTag, 1000&gt;</code>.</li> <li>No virtual overhead, heap allocation, or runtime type checks.</li> <li>Supports tick-based alignment and arithmetic directly without conversions.</li> <li>Used throughout Flox for price, quantity, and other numeric domains.</li> </ul>"},{"location":"components/util/concurrency/spsc_queue/","title":"SPSCQueue","text":"<p><code>SPSCQueue</code> is a lock-free, bounded-size single-producer/single-consumer queue optimized for HFT workloads. It supports in-place construction, zero allocations, and cache-line isolation.</p> <pre><code>template &lt;typename T, size_t Capacity&gt;\nclass SPSCQueue;\n</code></pre>"},{"location":"components/util/concurrency/spsc_queue/#purpose","title":"Purpose","text":"<ul> <li>Provide low-latency, zero-contention messaging between one writer and one reader.</li> </ul>"},{"location":"components/util/concurrency/spsc_queue/#requirements","title":"Requirements","text":"<ul> <li><code>Capacity</code> must be a power of two.</li> <li><code>T</code> must be nothrow-destructible.</li> <li>Only one producer and one consumer may operate concurrently.</li> </ul>"},{"location":"components/util/concurrency/spsc_queue/#key-features","title":"Key Features","text":"Method Description <code>push(const T&amp;)</code> Enqueues a copy of an object. <code>emplace(T&amp;&amp;)</code> Enqueues an rvalue object (move). <code>try_emplace(...)</code> Constructs object in-place with arguments. <code>pop(T&amp;)</code> Pops and moves the front element into <code>out</code>. <code>try_pop()</code> Returns a pointer to the front element, or <code>nullptr</code> if empty. <code>try_pop_ref()</code> Returns <code>std::optional&lt;std::reference_wrapper&lt;T&gt;&gt;</code> for inline access. <code>empty()</code> / <code>full()</code> Check queue state. <code>clear()</code> Destroys and drains all pending elements. <code>size()</code> Returns current number of elements."},{"location":"components/util/concurrency/spsc_queue/#internal-design","title":"Internal Design","text":"<ul> <li>Ring buffer implementation with <code>Capacity</code> entries, using modulo <code>MASK = Capacity - 1</code>.</li> <li><code>_head</code> and <code>_tail</code> are <code>std::atomic&lt;size_t&gt;</code> and are false-shared-safe via <code>alignas(64)</code>.</li> <li>Uses placement <code>new</code> for in-place construction, avoids heap entirely.</li> </ul>"},{"location":"components/util/concurrency/spsc_queue/#notes","title":"Notes","text":"<ul> <li>Optimized for predictable, sub-microsecond latency in tight loops.</li> <li>No memory reclamation or ABA protection \u2014 not suitable for multi-producer/multi-consumer setups.</li> <li>All methods use <code>memory_order_acquire/release</code> to ensure visibility across cores.</li> <li>Destruction ensures safe draining of remaining elements via <code>~T()</code> call.</li> </ul>"},{"location":"components/util/eventing/event_bus/","title":"EventBus","text":"<p><code>EventBus</code> is a lock-free fan-out messaging system for publishing typed events to multiple subscribers. It supports both push (threaded delivery) and pull (manual draining) modes, and is configurable for sync or async semantics via policy injection.</p> <pre><code>template &lt;typename Event, typename Policy, size_t QueueSize = config::DEFAULT_EVENTBUS_QUEUE_SIZE&gt;\nclass EventBus;\n</code></pre>"},{"location":"components/util/eventing/event_bus/#purpose","title":"Purpose","text":"<ul> <li>Deliver high-frequency events (market data, orders, etc.) to multiple subscribers with minimal latency and zero allocations.</li> </ul>"},{"location":"components/util/eventing/event_bus/#supported-policies","title":"Supported Policies","text":"Policy Description <code>AsyncPolicy</code> Lock-free delivery in per-subscriber threads with no tick synchronization. <code>SyncPolicy</code> Uses <code>TickBarrier</code> to coordinate delivery across all subscribers per tick."},{"location":"components/util/eventing/event_bus/#key-responsibilities","title":"Key Responsibilities","text":"Method Description <code>subscribe()</code> Registers a new subscriber with individual queue and mode. <code>publish()</code> Broadcasts an event to all subscribers; sync-mode waits for completion. <code>start()</code> / <code>stop()</code> Starts or stops all push-mode subscriber threads. <code>getQueue(id)</code> Provides direct access to a subscriber\u2019s queue (for pull-mode). <code>enableDrainOnStop()</code> Ensures any remaining events are dispatched before shutdown."},{"location":"components/util/eventing/event_bus/#design-highlights","title":"Design Highlights","text":"<ul> <li>Queue per subscriber: Each listener has a dedicated <code>SPSCQueue</code> to avoid contention.</li> <li>Thread-per-subscriber: Only for <code>PUSH</code> mode; <code>PULL</code> consumers must drain manually.</li> <li>RAII-controlled sync: <code>TickGuard</code> ensures deterministic behavior in <code>SyncPolicy</code>.</li> <li>Zero dynamic allocations in hot path (<code>emplace()</code> used directly).</li> <li>Tick-sequenced events: <code>tickSequence</code> field is automatically set if present.</li> </ul>"},{"location":"components/util/eventing/event_bus/#internal-types","title":"Internal Types","text":"Name Description <code>QueueItem</code> Depends on <code>Policy</code>: either raw <code>Event</code> or <code>(Event, TickBarrier*)</code>. <code>Listener</code> Inferred from <code>Event::Listener</code>. <code>Queue</code> Lock-free ring buffer (single producer/consumer). <code>Entry</code> Subscription record: listener, queue, thread, and mode."},{"location":"components/util/eventing/event_bus/#notes","title":"Notes","text":"<ul> <li>Sync-mode (<code>SyncPolicy</code>) is ideal for deterministic backtesting or simulation.</li> <li>Async-mode (<code>AsyncPolicy</code>) is best suited for ultra-low-latency live systems.</li> <li><code>EventBus</code> is fully generic \u2014 works with any event type that defines a <code>Listener</code>.</li> </ul>"},{"location":"components/util/eventing/event_bus/#example-usage","title":"Example Usage","text":"<pre><code>using BookBus = EventBus&lt;pool::Handle&lt;BookUpdateEvent&gt;, AsyncPolicy&lt;pool::Handle&lt;BookUpdateEvent&gt;&gt;&gt;;\nBookBus bus;\nbus.subscribe(bookHandler);\nbus.publish(bookUpdateHandle);\n</code></pre>"},{"location":"components/util/memory/pool/","title":"Pool &amp; Handle","text":"<p>This module implements a lock-free, reference-counted object pool for zero-allocation reuse of high-frequency data structures. It is optimized for HFT workloads with strict latency and memory control requirements.</p>"},{"location":"components/util/memory/pool/#poolpoolt-capacity","title":"<code>pool::Pool&lt;T, Capacity&gt;</code>","text":"<p>A statically sized memory pool for pre-allocating <code>T</code> objects that conform to the <code>Poolable</code> concept.</p> <pre><code>Pool&lt;BookUpdateEvent, 8192&gt; bookPool;\nauto handle = bookPool.acquire(); // returns optional&lt;Handle&lt;T&gt;&gt;\n</code></pre>"},{"location":"components/util/memory/pool/#purpose","title":"Purpose","text":"<ul> <li>Eliminate runtime allocations in performance-critical paths.</li> <li>Efficiently recycle reusable objects like events or buffers.</li> </ul>"},{"location":"components/util/memory/pool/#responsibilities","title":"Responsibilities","text":"Feature Description Allocation Constructs objects in-place using <code>std::pmr</code> memory resource. Recycling Returns objects to the pool via <code>releaseToPool()</code>. Ref-counting Uses intrusive reference counting (<code>retain</code>, <code>release</code>). Lifecycle Calls <code>clear()</code> and <code>resetRefCount()</code> on reuse."},{"location":"components/util/memory/pool/#poolhandlet","title":"<code>pool::Handle&lt;T&gt;</code>","text":"<p>A move-only, reference-counted smart pointer for objects allocated from the pool.</p> <pre><code>Handle&lt;BookUpdateEvent&gt; h = pool.acquire().value();\nh-&gt;tickSequence = 123;\n</code></pre>"},{"location":"components/util/memory/pool/#purpose_1","title":"Purpose","text":"<ul> <li>Safely manage lifetime of pooled objects without heap allocations.</li> </ul>"},{"location":"components/util/memory/pool/#features","title":"Features","text":"Feature Description Move-only Copy retains reference; assignment is deleted. Auto-release Returns to pool when last reference is destroyed. Type-safe cast <code>upcast&lt;U&gt;()</code> supports safe widening conversions."},{"location":"components/util/memory/pool/#type-requirements","title":"Type Requirements","text":"<p><code>T</code> must:</p> <ul> <li>Inherit from <code>RefCountable</code> and <code>PoolableBase&lt;T&gt;</code></li> <li> <p>Implement:</p> </li> <li> <p><code>clear()</code></p> </li> <li><code>setPool(void*)</code></li> <li><code>releaseToPool()</code></li> </ul>"},{"location":"components/util/memory/pool/#internal-design","title":"Internal Design","text":"<ul> <li><code>Pool&lt;T&gt;</code> uses <code>std::aligned_storage</code> for static placement.</li> <li>Objects are returned to the pool via an <code>SPSCQueue&lt;T*&gt;</code>.</li> <li>Backed by a <code>monotonic_buffer_resource</code> and <code>unsynchronized_pool_resource</code> for internal vector-like allocations.</li> </ul>"},{"location":"components/util/memory/pool/#notes","title":"Notes","text":"<ul> <li>Zero allocations in steady-state operation.</li> <li>Thread-safe for single-producer, single-consumer usage.</li> <li>All objects are destructed in-place on shutdown.</li> <li>Used extensively for <code>BookUpdateEvent</code>, <code>TradeEvent</code>, and other high-volume types.</li> </ul>"},{"location":"components/util/memory/ref_countable/","title":"RefCountable","text":"<p><code>RefCountable</code> is a low-overhead, intrusive reference counting base class. It enables manual control of object lifetime without dynamic memory management and is used as the foundation for pooled, shared objects in Flox.</p> <pre><code>class RefCountable {\npublic:\n  void retain() noexcept;\n  bool release() noexcept;\n  void resetRefCount(uint32_t value = 0) noexcept;\n  uint32_t refCount() const noexcept;\n};\n</code></pre>"},{"location":"components/util/memory/ref_countable/#purpose","title":"Purpose","text":"<ul> <li>Provide deterministic, allocation-free lifetime tracking for objects managed in pools or event buses.</li> </ul>"},{"location":"components/util/memory/ref_countable/#responsibilities","title":"Responsibilities","text":"Method Description <code>retain()</code> Increments reference count (non-atomic relaxed). <code>release()</code> Decrements reference count; returns <code>true</code> if last ref. <code>resetRefCount()</code> Resets ref count to 0 or specified value. <code>refCount()</code> Returns current ref count for debug/inspection."},{"location":"components/util/memory/ref_countable/#behavior","title":"Behavior","text":"<ul> <li>When <code>release()</code> returns <code>true</code>, the object is no longer in use and may be recycled.</li> <li>Incorrect calls (e.g. <code>release()</code> on <code>0</code>) are fatal in debug builds and abort in release.</li> </ul>"},{"location":"components/util/memory/ref_countable/#design-notes","title":"Design Notes","text":"<ul> <li>Uses <code>std::atomic&lt;uint32_t&gt;</code> with relaxed memory ordering for performance.</li> <li>Thread-safe under the assumption that retain/release are called from valid ownership contexts.</li> <li>Not designed for multi-owner concurrent access \u2014 intended for single-threaded or externally synchronized lifecycles.</li> </ul>"},{"location":"components/util/memory/ref_countable/#concept","title":"Concept","text":"<pre><code>template &lt;typename T&gt;\nconcept RefCountable = requires(T obj) {\n  { obj.retain() } -&gt; std::same_as&lt;void&gt;;\n  { obj.release() } -&gt; std::same_as&lt;bool&gt;;\n  { obj.resetRefCount() } -&gt; std::same_as&lt;void&gt;;\n};\n</code></pre> <p>This concept ensures compile-time validation for use in pooled or handle-managed objects.</p>"},{"location":"components/validation/abstract_order_validator/","title":"IOrderValidator","text":"<p><code>IOrderValidator</code> defines the interface for validating outbound orders before submission. It ensures correctness and compliance with predefined constraints (e.g. price ranges, order size).</p> <pre><code>class IOrderValidator : public ISubsystem {\npublic:\n  virtual ~IOrderValidator() = default;\n  virtual bool validate(const Order&amp; order, std::string&amp; reason) const = 0;\n};\n</code></pre>"},{"location":"components/validation/abstract_order_validator/#purpose","title":"Purpose","text":"<ul> <li>Prevent invalid or unsafe orders from reaching the execution layer by performing sanity checks.</li> </ul>"},{"location":"components/validation/abstract_order_validator/#responsibilities","title":"Responsibilities","text":"Method Description <code>validate</code> Checks if the order is valid. Returns <code>true</code> if valid; else sets <code>reason</code>."},{"location":"components/validation/abstract_order_validator/#notes","title":"Notes","text":"<ul> <li>Must be called prior to invoking <code>IOrderExecutor::submitOrder()</code>.</li> <li>Provides human-readable error messages via the <code>reason</code> output parameter.</li> <li> <p>Implementations can enforce checks such as:</p> </li> <li> <p>Non-zero quantity</p> </li> <li>Price within expected deviation</li> <li>Tick-size alignment</li> <li>Symbol validity</li> <li>Integrated into the engine as an <code>ISubsystem</code> for lifecycle coordination.</li> </ul>"},{"location":"usage/config/","title":"Configuration","text":"<p>Flox is configured via the <code>EngineConfig</code> structure, typically loaded from a JSON file or embedded configuration source.</p>"},{"location":"usage/config/#example","title":"Example","text":"<pre><code>{\n  \"logLevel\": \"debug\",\n  \"exchanges\": [\n    {\n      \"name\": \"bybit\",\n      \"type\": \"mock\",\n      \"symbols\": [\n        { \"symbol\": \"DOTUSDT\", \"tickSize\": 0.001, \"expectedDeviation\": 0.5 }\n      ]\n    }\n  ],\n  \"killSwitchConfig\": {\n    \"maxOrderQty\": 10000,\n    \"maxLoss\": -5000,\n    \"maxOrdersPerSecond\": 100\n  }\n}\n</code></pre>"},{"location":"usage/config/#fields","title":"Fields","text":""},{"location":"usage/config/#loglevel","title":"<code>logLevel</code>","text":"<p>Controls runtime logging verbosity (<code>debug</code>, <code>info</code>, <code>warn</code>, etc.)</p>"},{"location":"usage/config/#exchanges","title":"<code>exchanges[]</code>","text":"<p>Defines which exchange connectors to start and which symbols to subscribe to.</p> <ul> <li><code>name</code>: display label or unique ID for internal routing</li> <li><code>type</code>: used by <code>ConnectorFactory</code> to instantiate the appropriate connector</li> <li><code>symbols[]</code>: list of symbol configs with tick size and allowed deviation</li> </ul>"},{"location":"usage/config/#killswitchconfig","title":"<code>killSwitchConfig</code>","text":"<p>Defines runtime shutdown thresholds:</p> <ul> <li><code>maxOrderQty</code>: maximum order size allowed per submission</li> <li><code>maxLoss</code>: hard limit on realized/unrealized loss</li> <li><code>maxOrdersPerSecond</code>: rate limit for outbound orders (<code>-1</code> disables)</li> </ul>"},{"location":"usage/config/#notes","title":"Notes","text":"<ul> <li><code>SymbolId</code> is derived automatically from <code>(exchange, symbol)</code> during engine startup</li> <li>Tick size and deviation are used by validators and order book alignment</li> <li>All configuration is immutable after startup for safety and determinism</li> </ul>"},{"location":"usage/demo/","title":"Demo Application","text":"<p>The <code>demo</code> folder provides a minimal working example that wires Flox components into a functioning system. It demonstrates the architecture, event flow, and subsystem lifecycle in a controlled, simulated environment.</p>"},{"location":"usage/demo/#features","title":"Features","text":"<ul> <li><code>DemoConnector</code>: emits synthetic trades and book updates for testing</li> <li><code>DemoStrategy</code>: receives market data and generates mock orders</li> <li><code>SimpleOrderExecutor</code>: processes orders and triggers fills via <code>OrderExecutionBus</code></li> <li><code>SimplePnLTracker</code>, <code>SimpleKillSwitch</code>, <code>SimpleRiskManager</code>: lightweight control modules</li> <li><code>DemoBuilder</code>: constructs and wires all required subsystems and buses</li> </ul>"},{"location":"usage/demo/#running-the-demo","title":"Running the Demo","text":"<p>After building the project with CMake:</p> <pre><code>./demo/flox_demo\n</code></pre> <p>The demo will:</p> <ul> <li>Start two synthetic connectors</li> <li>Publish market data via <code>MarketDataBus</code></li> <li>Run the strategy and supporting systems for approximately five seconds</li> <li>Stop all components and exit cleanly</li> </ul>"},{"location":"usage/demo/#notes","title":"Notes","text":"<ul> <li>This demo is intended for integration testing and illustration only</li> <li>Production deployments should define their own builder and execution harness</li> <li>All demo components are isolated and can be replaced with real implementations</li> </ul>"},{"location":"usage/getting_started/","title":"Getting Started","text":"<p>This guide will help you build, test, and install Flox on your machine.</p>"},{"location":"usage/getting_started/#prerequisites","title":"Prerequisites","text":"<ul> <li>C++20 or later (e.g. GCC 13 or Clang 16+)</li> <li>CMake 3.22+</li> <li>Git</li> <li>Linux (recommended)</li> <li>GoogleTest and Google Benchmark</li> <li><code>clang-format</code> 18.1.8 (for development)</li> </ul>"},{"location":"usage/getting_started/#clone-and-build","title":"Clone and Build","text":"<pre><code>git clone https://github.com/eeiaao/flox.git\ncd flox\nmkdir build &amp;&amp; cd build\ncmake ..\nmake -j$(nproc)\n</code></pre>"},{"location":"usage/getting_started/#install-dependencies","title":"Install Dependencies","text":"<p>If GoogleTest and Google Benchmark are not installed system-wide:</p> <pre><code># GoogleTest\ngit clone --depth=1 https://github.com/google/googletest.git\ncmake -B gtest-build -S googletest\ncmake --build gtest-build --target gtest gtest_main gmock gmock_main\nsudo cmake --install gtest-build\n\n# Google Benchmark\ngit clone --depth=1 https://github.com/google/benchmark.git\ncmake -B benchmark-build -S benchmark -DCMAKE_BUILD_TYPE=Release -DBENCHMARK_DOWNLOAD_DEPENDENCIES=ON\ncmake --build benchmark-build -j$(nproc)\nsudo cmake --install benchmark-build\n</code></pre>"},{"location":"usage/getting_started/#clang-format-setup","title":"clang-format Setup","text":"<p>We use <code>clang-format</code> 18.x to enforce consistent style. Install it with:</p> <pre><code>sudo apt install -y wget gnupg lsb-release software-properties-common\nwget https://apt.llvm.org/llvm.sh\nchmod +x llvm.sh\nsudo ./llvm.sh 18\nsudo apt install -y clang-format-18\nsudo update-alternatives --install /usr/bin/clang-format clang-format /usr/bin/clang-format-18 100\n</code></pre>"},{"location":"usage/getting_started/#build-options","title":"Build Options","text":"<p>Flox supports optional components controlled via CMake flags:</p> Option Default Description <code>ENABLE_TESTS</code> <code>OFF</code> Build unit tests <code>ENABLE_BENCHMARK</code> <code>OFF</code> Build benchmark binaries <code>ENABLE_DEMO</code> <code>OFF</code> Build the demo application <p>To enable them:</p> <pre><code>cmake .. -DENABLE_TESTS=ON -DENABLE_BENCHMARK=ON -DENABLE_DEMO=ON\n</code></pre>"},{"location":"usage/getting_started/#run-tests","title":"Run Tests","text":"<p>From the <code>build</code> directory:</p> <pre><code>ctest --output-on-failure\n</code></pre>"},{"location":"usage/getting_started/#run-benchmarks","title":"Run Benchmarks","text":"<pre><code>./benchmarks/nlevel_order_book_benchmark\n</code></pre> <p>Or any other binary in <code>benchmarks/</code>.</p>"},{"location":"usage/getting_started/#install-system-wide","title":"Install System-Wide","text":"<pre><code>sudo make install\n</code></pre>"},{"location":"usage/getting_started/#code-style-and-contribution","title":"Code Style and Contribution","text":"<ul> <li>All contributions go through pull requests</li> <li>Use existing naming and directory conventions</li> <li>Add tests, benchmarks, and documentation where appropriate</li> </ul> <p>A <code>.clang-format</code> file is provided. A <code>pre-commit</code> hook is installed automatically during CMake configuration. It formats all changed <code>.cpp</code> and <code>.h</code> files.</p> <p>To install it manually:</p> <pre><code>cp scripts/pre-commit .git/hooks/pre-commit\nchmod +x .git/hooks/pre-commit\n</code></pre>"},{"location":"usage/getting_started/#using-flox-in-your-project","title":"Using Flox in Your Project","text":"<p>Flox is a low-latency infrastructure library. It is suitable for building:</p> <ul> <li>HFT engines</li> <li>Backtesters and simulators</li> <li>Custom execution pipelines</li> <li>Signal routers and adapters</li> </ul> <p>All components are modular, testable, and can be used independently.</p>"},{"location":"usage/running_engine/","title":"Running the Flox Engine","text":"<p>This guide explains how to initialize and run the Flox engine by wiring together subsystems, strategies, and connectors.</p>"},{"location":"usage/running_engine/#structure","title":"Structure","text":"<p>To launch the engine:</p> <ol> <li>Construct the required core subsystems (<code>MarketDataBus</code>, <code>OrderExecutionBus</code>, etc.)</li> <li>Register symbols using <code>SymbolRegistry</code></li> <li>Instantiate and configure exchange connectors</li> <li>Subscribe strategies and wire their dependencies</li> <li>Pass everything into the <code>Engine</code> constructor and call <code>start()</code></li> </ol>"},{"location":"usage/running_engine/#example","title":"Example","text":"<pre><code>EngineConfig config = loadConfig();  // Load from JSON or other source\n\nauto registry = std::make_unique&lt;SymbolRegistry&gt;();\nauto mdb = std::make_unique&lt;MarketDataBus&gt;();\nauto orderBus = std::make_unique&lt;OrderExecutionBus&gt;();\n\nConnectorFactory::instance().registerConnector(\"bybit\",\n  [mdb = mdb.get(), registry = registry.get()](const std::string&amp; symbolStr) {\n    auto symbolId = registry-&gt;getSymbolId(\"bybit\", symbolStr);\n    auto conn = std::make_shared&lt;BybitExchangeConnector&gt;(symbolStr, *symbolId);\n    conn-&gt;setCallbacks(\n      [mdb](EventHandle&lt;BookUpdateEvent&gt; b) { mdb-&gt;publish(std::move(b)); },\n      [mdb](const TradeEvent&amp; t) { mdb-&gt;publish(t); });\n    return conn;\n  });\n\nstd::vector&lt;std::shared_ptr&lt;ExchangeConnector&gt;&gt; connectors;\nstd::vector&lt;std::unique_ptr&lt;ISubsystem&gt;&gt; subsystems;\n\n// Register symbols and create connectors\nfor (const auto&amp; ex : config.exchanges) {\n  for (const auto&amp; sym : ex.symbols) {\n    registry-&gt;registerSymbol(ex.name, sym.symbol);\n    auto conn = ConnectorFactory::instance().createConnector(ex.name, sym.symbol);\n    if (conn) connectors.push_back(conn);\n  }\n}\n\n// Load and wire strategies\nstd::vector&lt;std::shared_ptr&lt;IStrategy&gt;&gt; strategies = loadStrategiesFromConfig(registry.get());\nfor (const auto&amp; strat : strategies) {\n  auto executor = std::make_unique&lt;SimpleOrderExecutor&gt;(*orderBus);\n  strat-&gt;setOrderExecutor(executor.get());\n  subsystems.push_back(std::move(executor));\n  mdb-&gt;subscribe(strat);\n}\n\n// Final wiring\nsubsystems.push_back(std::move(mdb));\nsubsystems.push_back(std::move(orderBus));\nsubsystems.push_back(std::make_unique&lt;Subsystem&lt;SymbolRegistry&gt;&gt;(std::move(registry)));\n\nEngine engine(config, std::move(subsystems), std::move(connectors));\nengine.start();\n</code></pre>"},{"location":"usage/running_engine/#notes","title":"Notes","text":"<ul> <li>Strategies must implement <code>IMarketDataSubscriber</code></li> <li>Subsystems must inherit from <code>ISubsystem</code> or be wrapped in <code>Subsystem&lt;T&gt;</code></li> <li>Connectors are responsible for publishing <code>BookUpdateEvent</code> and <code>TradeEvent</code> into the bus</li> <li>All components must be constructed and wired manually before engine startup</li> </ul>"},{"location":"usage/running_engine/#lifecycle","title":"Lifecycle","text":"<p>The engine will:</p> <ol> <li>Start all subsystems</li> <li>Start all exchange connectors</li> <li>Begin dispatching events to strategies via <code>MarketDataBus</code></li> <li>Continue running until stopped or externally terminated</li> </ol> <p>Use this pattern to construct simulation environments, test harnesses, or live trading nodes.</p>"},{"location":"usage/strategies/","title":"Writing Strategies","text":"<p>Strategies in Flox are implemented by subclassing <code>IStrategy</code>, which defines a uniform interface for receiving market data and submitting orders. Strategies are market data subscribers with execution capability and injected dependencies.</p>"},{"location":"usage/strategies/#purpose","title":"Purpose","text":"<p>Encapsulate trading logic that reacts to market data and interacts with execution and control systems.</p>"},{"location":"usage/strategies/#interface-overview","title":"Interface Overview","text":"<pre><code>class IStrategy : public IMarketDataSubscriber {\n public:\n  // Lifecycle\n  virtual void onStart();\n  virtual void onStop();\n\n  // Market data callbacks\n  virtual void onCandle(const CandleEvent&amp; candle) override;\n  virtual void onTrade(const TradeEvent&amp; trade) override;\n  virtual void onBookUpdate(const BookUpdateEvent&amp; bookUpdate) override;\n\n  // Identification and mode\n  SubscriberId id() const override;\n  SubscriberMode mode() const override;\n};\n</code></pre>"},{"location":"usage/strategies/#strategy-lifecycle","title":"Strategy Lifecycle","text":"<ul> <li><code>onStart()</code> \u2014 called by the engine at startup before any events</li> <li><code>onStop()</code> \u2014 called before engine shutdown</li> </ul>"},{"location":"usage/strategies/#market-data","title":"Market Data","text":"<p>Strategies receive <code>BookUpdateEvent</code>, <code>TradeEvent</code>, and <code>CandleEvent</code> through their respective callbacks, depending on subscription mode.</p>"},{"location":"usage/strategies/#execution-and-control","title":"Execution and Control","text":"<p>All dependencies (e.g., order executor, validator, risk manager) must be owned or held directly by the strategy implementation. There are no getters or internal indirection in the base class. Example:</p> <pre><code>class MyStrategy : public IStrategy {\npublic:\n  MyStrategy(IOrderExecutor* executor,\n             IRiskManager* risk,\n             IOrderValidator* validator)\n    : _executor(executor), _risk(risk), _validator(validator) {}\n\n  void onBookUpdate(const BookUpdateEvent&amp; update) override {\n    if (!shouldEnter(update)) return;\n\n    Order order = buildOrder(update);\n\n    std::string reason;\n    if (_validator &amp;&amp; !_validator-&gt;validate(order, reason)) return;\n    if (_risk &amp;&amp; !_risk-&gt;allow(order)) return;\n\n    _executor-&gt;submitOrder(order);\n  }\n\nprivate:\n  IOrderExecutor* _executor;\n  IRiskManager* _risk;\n  IOrderValidator* _validator;\n\n  bool shouldEnter(const BookUpdateEvent&amp; update) const {\n    return (update.bestAskPrice() - update.bestBidPrice()) &gt;= MinSpread;\n  }\n\n  Order buildOrder(const BookUpdateEvent&amp; update) const {\n    return Order{\n      .symbol = update.symbol(),\n      .side = Side::BUY,\n      .price = update.bestBidPrice() + TickImprovement,\n      .quantity = DefaultQuantity,\n      .type = OrderType::LIMIT\n    };\n  }\n\n  static constexpr Price TickImprovement = 0.01;\n  static constexpr Price MinSpread = 0.03;\n  static constexpr Quantity DefaultQuantity = 100;\n};\n</code></pre>"},{"location":"usage/strategies/#best-practices","title":"Best Practices","text":"<ul> <li>Keep callbacks non-blocking</li> <li>Never retain raw event pointers</li> <li>Avoid unnecessary dependencies</li> <li>Own or store all dependencies explicitly in the strategy</li> </ul>"},{"location":"usage/strategies/#integration","title":"Integration","text":"<p>Strategies are wired with their dependencies in the engine builder or main application, and subscribed to the relevant buses. PULL or PUSH mode is selectable via <code>mode()</code> override.</p>"}]}